<!DOCTYPE html>
<html lang="zh-TW">
	<head>
		<meta charset="UTF-8" />
		<title>Quake Style FPS v3.17</title>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}
			body {
				overflow: hidden;
				background: #000;
				font-family: 'Courier New', monospace;
			}
			canvas {
				display: block;
			}
			#crosshair {
				position: fixed;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				pointer-events: none;
				z-index: 100;
			}
			#crosshair::before,
			#crosshair::after {
				content: '';
				position: absolute;
				background: #0f0;
				box-shadow: 0 0 5px #0f0;
			}
			#crosshair::before {
				width: 20px;
				height: 2px;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
			}
			#crosshair::after {
				width: 2px;
				height: 20px;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
			}
			#hud {
				position: fixed;
				bottom: 0;
				left: 0;
				right: 0;
				background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
				padding: 20px;
				z-index: 100;
				pointer-events: none;
				display: flex;
				justify-content: space-between;
				align-items: flex-end;
			}
			.hud-panel {
				background: rgba(80, 40, 0, 0.8);
				border: 3px solid #c80;
				padding: 10px 20px;
				color: #fc0;
				text-shadow: 0 0 10px #f80;
				font-size: 24px;
				font-weight: bold;
			}
			.hud-panel span {
				color: #fff;
				font-size: 32px;
			}
			#scoreBoard {
				position: fixed;
				top: 20px;
				left: 50%;
				transform: translateX(-50%);
				color: #fc0;
				font-size: 20px;
				text-align: center;
				text-shadow: 0 0 10px #f80;
				z-index: 100;
				pointer-events: none;
			}
			#damageOverlay {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				pointer-events: none;
				z-index: 99;
				background: radial-gradient(ellipse at center, transparent 0%, rgba(255, 0, 0, 0) 100%);
				opacity: 0;
				transition: opacity 0.1s;
			}
			#startScreen {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: linear-gradient(135deg, #1a0a00 0%, #3d1a00 50%, #1a0a00 100%);
				display: flex;
				flex-direction: row;
				align-items: center;
				justify-content: center;
				z-index: 200;
				color: #fff;
				padding: 20px;
			}
			#startScreen .left-panel {
				flex: 1;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				padding: 20px;
			}
			#startScreen .right-panel {
				flex: 1;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				padding: 20px;
			}
			#startScreen h1 {
				font-size: 64px;
				color: #f60;
				text-shadow: 0 0 30px #f00, 0 0 60px #f00, 0 5px 10px #000;
				margin-bottom: 5px;
				letter-spacing: 8px;
				animation: pulse 2s infinite;
			}
			@keyframes pulse {
				0%,
				100% {
					text-shadow: 0 0 30px #f00, 0 0 60px #f00;
				}
				50% {
					text-shadow: 0 0 50px #ff0, 0 0 100px #f80;
				}
			}
			#startScreen h2 {
				font-size: 20px;
				color: #c80;
				margin-bottom: 20px;
			}
			#startScreen .instructions {
				font-size: 14px;
				line-height: 1.8;
				margin-bottom: 20px;
				text-align: left;
				color: #fa0;
				background: rgba(0, 0, 0, 0.5);
				padding: 15px 25px;
				border: 2px solid #840;
				max-height: 80vh;
				overflow-y: auto;
			}
			#startScreen .instructions p {
				margin: 3px 0;
			}
			#startScreen .instructions span {
				color: #0f0;
				font-weight: bold;
			}
			#startScreen .features {
				font-size: 14px;
				line-height: 1.8;
				text-align: left;
				color: #fa0;
				background: rgba(0, 0, 0, 0.5);
				padding: 15px 25px;
				border: 2px solid #840;
			}
			#startScreen .features p {
				margin: 3px 0;
			}
			#startScreen button {
				padding: 15px 50px;
				font-size: 24px;
				background: linear-gradient(180deg, #f60, #800);
				color: #fff;
				border: 3px solid #fc0;
				cursor: pointer;
				text-shadow: 0 2px 5px #000;
				font-family: 'Courier New', monospace;
				font-weight: bold;
				animation: buttonGlow 1.5s infinite;
				margin-top: 20px;
			}
			@keyframes buttonGlow {
				0%,
				100% {
					box-shadow: 0 0 20px #f60;
				}
				50% {
					box-shadow: 0 0 40px #ff0, 0 0 60px #f80;
				}
			}
			#startScreen button:hover {
				transform: scale(1.1);
			}
			#gameOverScreen {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: rgba(20, 0, 0, 0.95);
				display: none;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				z-index: 200;
				color: #fff;
			}
			#gameOverScreen h1 {
				font-size: 64px;
				color: #f00;
				text-shadow: 0 0 30px #f00;
				margin-bottom: 20px;
			}
			#gameOverScreen button {
				padding: 15px 50px;
				font-size: 24px;
				margin-top: 20px;
				background: linear-gradient(180deg, #f60, #800);
				color: #fff;
				border: 2px solid #fc0;
				cursor: pointer;
			}
			#hitMarker {
				position: fixed;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				font-size: 40px;
				color: #f00;
				z-index: 101;
				opacity: 0;
				pointer-events: none;
				text-shadow: 0 0 10px #f00;
			}
			#weapon {
				position: fixed;
				bottom: 0;
				right: 50px;
				width: 350px;
				height: 250px;
				z-index: 98;
				pointer-events: none;
			}
			#muzzleFlash {
				position: fixed;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				width: 100px;
				height: 100px;
				background: radial-gradient(
					circle,
					rgba(255, 200, 0, 0.8) 0%,
					rgba(255, 100, 0, 0.5) 30%,
					transparent 70%
				);
				border-radius: 50%;
				z-index: 97;
				pointer-events: none;
				opacity: 0;
			}
			#message {
				position: fixed;
				top: 100px;
				left: 50%;
				transform: translateX(-50%);
				font-size: 32px;
				color: #0f0;
				text-shadow: 0 0 20px #0f0;
				z-index: 100;
				opacity: 0;
				transition: opacity 0.3s;
			}
			#fpsCounter {
				position: fixed;
				top: 5px;
				right: 20px;
				color: #0f0;
				font-size: 14px;
				font-family: 'Courier New', monospace;
				z-index: 101;
				text-shadow: 0 0 5px #000;
			}
			#minimap {
				position: fixed;
				top: 25px;
				right: 20px;
				width: 150px;
				height: 150px;
				background: rgba(0, 0, 0, 0.7);
				border: 2px solid #f80;
				border-radius: 5px;
				z-index: 100;
			}
			#killStreak {
				position: fixed;
				top: 60px;
				left: 50%;
				transform: translateX(-50%);
				font-size: 48px;
				color: #ff0;
				text-shadow: 0 0 30px #f80, 0 0 60px #f00;
				z-index: 100;
				opacity: 0;
				transition: opacity 0.3s;
				font-weight: bold;
			}
			#speedLines {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				pointer-events: none;
				z-index: 50;
				background: radial-gradient(ellipse at center, transparent 60%, rgba(0, 0, 0, 0.3) 100%);
				opacity: 0;
				transition: opacity 0.2s;
			}
			#healthBar {
				position: fixed;
				bottom: 80px;
				left: 20px;
				width: 200px;
				height: 8px;
				background: #333;
				border: 1px solid #666;
				z-index: 100;
			}
			#healthBarFill {
				height: 100%;
				background: linear-gradient(90deg, #f00, #ff0);
				transition: width 0.3s;
			}
			.combo-text {
				position: fixed;
				font-size: 24px;
				color: #ff0;
				text-shadow: 0 0 10px #f80;
				pointer-events: none;
				z-index: 100;
				animation: floatUp 1s ease-out forwards;
			}
			@keyframes floatUp {
				0% {
					opacity: 1;
					transform: translateY(0);
				}
				100% {
					opacity: 0;
					transform: translateY(-50px);
				}
			}
		</style>
	</head>
	<body>
		<div id="crosshair"></div>
		<div id="hitMarker">âœ–</div>
		<div id="muzzleFlash"></div>
		<div id="message"></div>
		<div id="killStreak"></div>
		<div id="speedLines"></div>
		<div id="fpsCounter">FPS: --</div>
		<canvas id="minimap"></canvas>
		<div id="healthBar"><div id="healthBarFill"></div></div>
		<canvas id="weapon"></canvas>
		<div id="hud">
			<div class="hud-panel">HEALTH <span id="health">100</span></div>
			<div
				class="hud-panel"
				id="weaponPanel">
				ğŸ”« SMG <span id="ammo">30</span>/<span id="maxAmmo">30</span>
			</div>
			<div
				class="hud-panel"
				id="rocketPanel"
				style="opacity: 0.5">
				ğŸš€ RPG <span id="rocketAmmo">10</span>
			</div>
			<div
				class="hud-panel"
				id="grenadePanel"
				style="opacity: 0.5">
				ğŸ’£ GREN <span id="grenadeAmmo">5</span>
			</div>
		</div>
		<div id="scoreBoard">
			<div>
				WAVE: <span id="waveNum">1</span><span id="waveMarkers" style="color:#f80"></span> / 10 |
				TARGET: <span id="waveKills" style="color:#0f0">0</span>/<span id="waveKillTarget">0</span> |
				SCORE: <span id="totalScore">0</span>
			</div>
		</div>
		<div
			id="weaponName"
			style="position: fixed; bottom: 120px; right: 30px; color: #ff0; font-size: 18px; z-index: 100">
			[ 1 ] SMG
		</div>
		<div id="damageOverlay"></div>
		<div id="startScreen">
			<div class="left-panel">
				<h1>QUAKE</h1>
				<h2>ğŸ”¥ BROWSER EDITION v3.17 ğŸ”¥</h2>
				<div class="instructions">
					<p><span>W A S D</span> - ç§»å‹•</p>
					<p><span>SPACE</span> - è·³èº</p>
					<p><span>SHIFT</span> - è¡åˆº</p>
					<p><span>æ»‘é¼ </span> - ç„æº–</p>
					<p><span>å·¦éµ</span> - å°„æ“Š</p>
					<p><span>å³éµ / R</span> - æ›å½ˆ</p>
					<p><span>1</span> - è¡é‹’æ§ ğŸ”«</p>
					<p><span>2</span> - ç«ç®­ç ² ğŸš€</p>
					<p><span>3</span> - æ‰‹æ¦´å½ˆ ğŸ’£</p>
					<p><span>æ»¾è¼ª</span> - åˆ‡æ›æ­¦å™¨ ğŸ”„</p>
					<p><span>Q</span> - Debugæ¨¡å¼ ğŸ”§</p>
				</div>

				<button id="startBtn">â–¶ START GAME</button>
			</div>
			<div class="right-panel">
				<div class="features">
					<p style="color: #ff0; font-size: 16px; margin-bottom: 10px">ã€éŠæˆ²ç‰¹è‰²ã€‘</p>
					<p style="color: #f55">ğŸ¯ æ¨™é¶å››é¢ä¸åŒåˆ†æ•¸ï¼ç„æº–é«˜åˆ†é¢ï¼</p>
					<p style="color: #5ff">ğŸ’¥ ç«ç®­ç ²çˆ†ç‚¸ç¯„åœå‚·å®³ï¼</p>
					<p style="color: #f80">ğŸš€ ç«ç®­è·³ï¼å°åœ°å°„æ“Šå¯å½ˆé£› (è‡ªå‚·20é»)</p>
					<p style="color: #0ff">â¬†ï¸ è—è‰²å½ˆè·³æ¿ = è¶…ç´šè·³èº!</p>
					<p style="color: #f00">â˜ ï¸ ç´…è‰²åœ°æ¿ = å‚·å®³å€åŸŸ (éš¨æ©Ÿä½ç½®)</p>
					<p style="color: #8f8; margin-top: 10px">ğŸŒ³ å¾€å‰æ¢ç´¢æˆ¶å¤–å€åŸŸ!</p>
					<p style="color: #aaf">ğŸ”ï¸ å®¤å…§å¯†å®¤ + æˆ¶å¤–è‰åœ°</p>
					<p style="color: #ffa">â˜€ï¸ è—å¤©ç™½é›²ï¼Œé™½å…‰æ™®ç…§</p>
				</div>
			</div>
		</div>
		<div id="gameOverScreen">
			<h1>YOU DIED</h1>
			<div style="font-size: 24px; color: #fc0; margin: 10px 0">
				WAVE: <span id="finalWave">1</span> | KILLS: <span id="finalKills">0</span>
			</div>
			<div style="font-size: 32px; color: #ff0; margin: 10px 0">SCORE: <span id="finalScore">0</span></div>
			<button id="restartBtn">â–¶ TRY AGAIN</button>
		</div>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
		<script>
			let scene, camera, renderer;
			let player = {
				health: 100,
				maxHealth: 100,
				armor: 50,
				ammo: 30,
				maxAmmo: 30,
				rocketAmmo: 10,
				maxRocketAmmo: 10,
				grenadeAmmo: 5,
				maxGrenadeAmmo: 5,
				kills: 0,
				speed: 0.18,
				sprintSpeed: 0.35,
				jumpForce: 0.3,
				velocity: { x: 0, y: 0, z: 0 },
				onGround: true,
				isReloading: false,
				isSprinting: false,
				height: 1.7,
				bobPhase: 0,
				currentWeapon: 1, // 1=è¡é‹’æ§, 2=ç«ç®­ç ²
			};

			let keys = {};
			let isPointerLocked = false;
			let enemies = [];
			let walls = [];
			let floors = []; // åœ°æ¿ï¼ˆåªç”¨æ–¼å°„ç·šæª¢æ¸¬ï¼Œä¸æ“‹ç§»å‹•ï¼‰
			let ramps = []; // æ–œå¡ï¼ˆåªå½±éŸ¿Yè»¸é«˜åº¦ï¼Œä¸æ“‹XZç§»å‹•ï¼‰
			let targets = []; // å¯ç ´å£çš„ç®±å­æ¨™é¶
			let bullets = []; // å­å½ˆè»Œè·¡
			let rockets = []; // ç«ç®­
			let pickups = [];
			let decals = [];
			let healthBoxes = []; // é†«ç™‚ç®±
			let enemyProjectiles = []; // æ•µäººæŠ•å°„ç‰©ï¼ˆçŸ³é ­ã€ç«çƒï¼‰
			let healthPickups = []; // æ‰è½çš„æ„›å¿ƒ
			let gameStarted = false;
			let gameOver = false;
			let lastShootTime = 0;
			let weaponRecoil = 0;
			let difficulty = 1;
			let killStreak = 0;
			let lastKillTime = 0;
			let screenShake = 0;
			let roundScore = 0; // æœ¬è¼ªåˆ†æ•¸
			let totalScore = 0; // ç¸½åˆ†
			let debugMode = false; // Debugæ¨¡å¼ï¼šé¡¯ç¤ºå½ˆè‘—é»+æ•µäººæš«åœ

			// FPS è¨ˆæ•¸å™¨
			let fpsFrames = 0;
			let fpsLastTime = performance.now();
			let fpsDisplay = 0;

			// deltaTime ç³»çµ± - æ¨™æº–åŒ–éŠæˆ²æ™‚é–“
			let lastFrameTime = performance.now();
			let deltaTime = 0;  // å–®ä½ï¼šç§’
			const TARGET_FPS = 60;  // åŸºæº–å¹€ç‡

			// è¦–è§’æ§åˆ¶ - ç”¨ç¨ç«‹è®Šæ•¸é¿å…è¬å‘ç¯€æ­»é–
			let cameraYaw = 0; // å·¦å³è½‰ (Yè»¸)
			let cameraPitch = 0; // æŠ¬é ­ä½é ­ (Xè»¸)

			// éŸ³æ•ˆç³»çµ± (ä½¿ç”¨ Web Audio API ç”Ÿæˆ)
			const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

			function playSound(type) {
				const oscillator = audioCtx.createOscillator();
				const gainNode = audioCtx.createGain();
				oscillator.connect(gainNode);
				gainNode.connect(audioCtx.destination);

				if (type === 'shoot') {
					oscillator.type = 'sawtooth';
					oscillator.frequency.setValueAtTime(150, audioCtx.currentTime);
					oscillator.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.1);
					gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
					gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
					oscillator.start(audioCtx.currentTime);
					oscillator.stop(audioCtx.currentTime + 0.1);
				} else if (type === 'hit') {
					oscillator.type = 'square';
					oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
					oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.05);
					gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
					gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
					oscillator.start(audioCtx.currentTime);
					oscillator.stop(audioCtx.currentTime + 0.05);
				} else if (type === 'kill') {
					oscillator.type = 'sine';
					oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
					oscillator.frequency.setValueAtTime(800, audioCtx.currentTime + 0.1);
					oscillator.frequency.setValueAtTime(1000, audioCtx.currentTime + 0.2);
					gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
					gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
					oscillator.start(audioCtx.currentTime);
					oscillator.stop(audioCtx.currentTime + 0.3);
				} else if (type === 'hurt') {
					oscillator.type = 'sawtooth';
					oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
					oscillator.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.2);
					gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
					gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
					oscillator.start(audioCtx.currentTime);
					oscillator.stop(audioCtx.currentTime + 0.2);
				} else if (type === 'reload') {
					// å¡«å½ˆéŸ³æ•ˆ - é‡‘å±¬ç¢°æ’è²
					oscillator.type = 'square';
					oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
					oscillator.frequency.setValueAtTime(600, audioCtx.currentTime + 0.05);
					oscillator.frequency.setValueAtTime(1000, audioCtx.currentTime + 0.15);
					oscillator.frequency.setValueAtTime(700, audioCtx.currentTime + 0.25);
					gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
					gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime + 0.1);
					gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime + 0.2);
					gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
					oscillator.start(audioCtx.currentTime);
					oscillator.stop(audioCtx.currentTime + 0.4);
				} else if (type === 'empty') {
					// ç©ºå½ˆå¤¾éŸ³æ•ˆ - å’–å’–å…©è²
					oscillator.type = 'square';
					oscillator.frequency.setValueAtTime(150, audioCtx.currentTime);
					oscillator.frequency.setValueAtTime(100, audioCtx.currentTime + 0.08);
					oscillator.frequency.setValueAtTime(150, audioCtx.currentTime + 0.2);
					oscillator.frequency.setValueAtTime(100, audioCtx.currentTime + 0.28);
					gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
					gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime + 0.1);
					gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime + 0.2);
					gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
					oscillator.start(audioCtx.currentTime);
					oscillator.stop(audioCtx.currentTime + 0.4);
				} else if (type === 'explosion') {
					// çˆ†ç‚¸éŸ³æ•ˆ - ä½é »å™ªéŸ³
					oscillator.type = 'sawtooth';
					oscillator.frequency.setValueAtTime(80, audioCtx.currentTime);
					oscillator.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 0.5);
					gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
					gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
					oscillator.start(audioCtx.currentTime);
					oscillator.stop(audioCtx.currentTime + 0.5);
				} else if (type === 'jump') {
					// å½ˆè·³éŸ³æ•ˆ - ä¸Šå‡éŸ³èª¿
					oscillator.type = 'sine';
					oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
					oscillator.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.2);
					gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
					gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
					oscillator.start(audioCtx.currentTime);
					oscillator.stop(audioCtx.currentTime + 0.3);
				}
			}

			// è²¼åœ–ç”Ÿæˆå™¨
			function createTexture(type) {
				const canvas = document.createElement('canvas');
				canvas.width = 256;
				canvas.height = 256;
				const ctx = canvas.getContext('2d');

				if (type === 'brick') {
					// æš—ç´…è‰²ç£šç‰†è²¼åœ–
					ctx.fillStyle = '#3a2020';
					ctx.fillRect(0, 0, 256, 256);

					const brickH = 32;
					const brickW = 64;
					for (let row = 0; row < 8; row++) {
						const offset = (row % 2) * (brickW / 2);
						for (let col = -1; col < 5; col++) {
							const x = col * brickW + offset;
							const y = row * brickH;

							// ç£šå¡Šä¸»é«”
							const shade = 0.7 + Math.random() * 0.3;
							ctx.fillStyle = `rgb(${Math.floor(120 * shade)}, ${Math.floor(50 * shade)}, ${Math.floor(
								50 * shade
							)})`;
							ctx.fillRect(x + 2, y + 2, brickW - 4, brickH - 4);

							// ç£šå¡Šç´‹ç†
							for (let i = 0; i < 20; i++) {
								ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.2})`;
								ctx.fillRect(x + Math.random() * brickW, y + Math.random() * brickH, 3, 3);
							}
						}
						// æ°´å¹³ç¸«éš™
						ctx.fillStyle = '#1a0808';
						ctx.fillRect(0, row * brickH, 256, 3);
					}
				} else if (type === 'metal') {
					// é‡‘å±¬åœ°æ¿
					ctx.fillStyle = '#2a2a30';
					ctx.fillRect(0, 0, 256, 256);

					// æ ¼å­ç´‹è·¯
					const gridSize = 64;
					for (let y = 0; y < 4; y++) {
						for (let x = 0; x < 4; x++) {
							const shade = 0.8 + Math.random() * 0.2;
							ctx.fillStyle = `rgb(${Math.floor(50 * shade)}, ${Math.floor(55 * shade)}, ${Math.floor(
								60 * shade
							)})`;
							ctx.fillRect(x * gridSize + 2, y * gridSize + 2, gridSize - 4, gridSize - 4);

							// é‰šé‡˜
							ctx.fillStyle = '#555';
							ctx.beginPath();
							ctx.arc(x * gridSize + 8, y * gridSize + 8, 4, 0, Math.PI * 2);
							ctx.fill();
							ctx.beginPath();
							ctx.arc(x * gridSize + gridSize - 8, y * gridSize + 8, 4, 0, Math.PI * 2);
							ctx.fill();
							ctx.beginPath();
							ctx.arc(x * gridSize + 8, y * gridSize + gridSize - 8, 4, 0, Math.PI * 2);
							ctx.fill();
							ctx.beginPath();
							ctx.arc(x * gridSize + gridSize - 8, y * gridSize + gridSize - 8, 4, 0, Math.PI * 2);
							ctx.fill();
						}
					}

					// åˆ®ç—•
					ctx.strokeStyle = 'rgba(100,100,110,0.3)';
					ctx.lineWidth = 1;
					for (let i = 0; i < 15; i++) {
						ctx.beginPath();
						ctx.moveTo(Math.random() * 256, Math.random() * 256);
						ctx.lineTo(Math.random() * 256, Math.random() * 256);
						ctx.stroke();
					}
				} else if (type === 'ceiling') {
					// å¤©èŠ±æ¿è²¼åœ–
					ctx.fillStyle = '#1a1a1a';
					ctx.fillRect(0, 0, 256, 256);

					// ç®¡ç·š/æ¨‘
					ctx.fillStyle = '#252525';
					ctx.fillRect(0, 60, 256, 40);
					ctx.fillRect(0, 160, 256, 40);
					ctx.fillRect(60, 0, 40, 256);
					ctx.fillRect(160, 0, 40, 256);

					// æ±¡æ¼¬
					for (let i = 0; i < 30; i++) {
						ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.3})`;
						ctx.beginPath();
						ctx.arc(Math.random() * 256, Math.random() * 256, 5 + Math.random() * 20, 0, Math.PI * 2);
						ctx.fill();
					}
				} else if (type === 'crate') {
					// ç®±å­è²¼åœ–
					ctx.fillStyle = '#5a4030';
					ctx.fillRect(0, 0, 256, 256);

					// æœ¨æ¿ç´‹è·¯
					ctx.fillStyle = '#4a3020';
					for (let i = 0; i < 6; i++) {
						ctx.fillRect(0, i * 45 + 3, 256, 3);
					}

					// é‚Šæ¡†
					ctx.strokeStyle = '#2a1a10';
					ctx.lineWidth = 8;
					ctx.strokeRect(10, 10, 236, 236);

					// é‡‘å±¬ç‰‡
					ctx.fillStyle = '#666';
					ctx.fillRect(100, 100, 56, 56);
					ctx.fillStyle = '#888';
					ctx.fillRect(105, 105, 46, 46);
				}

				const texture = new THREE.CanvasTexture(canvas);
				texture.wrapS = THREE.RepeatWrapping;
				texture.wrapT = THREE.RepeatWrapping;
				return texture;
			}

			// æè³ª
			let brickTexture, metalTexture, ceilingTexture, crateTexture;

			function init() {
				scene = new THREE.Scene();
				scene.background = new THREE.Color(0xffffff); // ç™½è‰²å¤©ç©ºèƒŒæ™¯
				scene.fog = new THREE.FogExp2(0xffffff, 0.008); // ç™½è‰²éœ§ï¼Œè¼ƒæ·¡

				camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
				camera.position.set(15, player.height, -15); // å‡ºç”Ÿåœ¨å®¤å…§å®‰å…¨ä½ç½®
				camera.rotation.order = 'YXZ'; // é‡è¦ï¼šé¿å…è¬å‘ç¯€æ­»é–

				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				document.body.appendChild(renderer.domElement);

				// å‰µå»ºè²¼åœ–
				brickTexture = createTexture('brick');
				metalTexture = createTexture('metal');
				ceilingTexture = createTexture('ceiling');
				crateTexture = createTexture('crate');

				// å…‰æº - æ˜äº®ä½†æœ‰æ°£æ°›
				const ambient = new THREE.AmbientLight(0x666666, 0.8);
				scene.add(ambient);

				// ä¸»å…‰æº - æ¨¡æ“¬å¤©èŠ±æ¿ç‡ˆ
				const mainLight = new THREE.DirectionalLight(0xffffff, 0.6);
				mainLight.position.set(0, 10, 0);
				scene.add(mainLight);

				// æ©™ç´…è‰²é»å…‰æºç‡Ÿé€ æˆ°é¬¥æ°›åœ
				const redLight1 = new THREE.PointLight(0xff4400, 1.5, 50);
				redLight1.position.set(20, 6, 20);
				scene.add(redLight1);

				const redLight2 = new THREE.PointLight(0xff4400, 1.5, 50);
				redLight2.position.set(-20, 6, -20);
				scene.add(redLight2);

				const redLight3 = new THREE.PointLight(0xff6600, 1.2, 40);
				redLight3.position.set(0, 6, 0);
				scene.add(redLight3);

				// å››è§’è£œå…‰
				const blueLight1 = new THREE.PointLight(0x4488ff, 0.6, 35);
				blueLight1.position.set(35, 5, 35);
				scene.add(blueLight1);

				const blueLight2 = new THREE.PointLight(0x4488ff, 0.6, 35);
				blueLight2.position.set(-35, 5, -35);
				scene.add(blueLight2);

				// ç©å®¶æ‰‹é›»ç­’ - æ›´äº®
				const flashlight = new THREE.SpotLight(0xffffee, 1.2, 60, Math.PI / 5, 0.3);
				flashlight.position.set(0, 0, 0);
				camera.add(flashlight);
				flashlight.target.position.set(0, 0, -1);
				camera.add(flashlight.target);
				scene.add(camera);

				createMap();
				setupEvents();
				drawWeapon();
				drawMinimap();
				animate();
			}

			// å‚·å®³åœ°æ¿å’Œå½ˆè·³å€é™£åˆ—
			let damageZones = [];
			let jumpPads = [];
			let damageZoneMeshes = []; // ç”¨æ–¼é‡ç½®æ™‚æ¸…é™¤

			function createMap() {
				const ceilingHeight = 20; // å®¤å…§å¤©èŠ±æ¿é«˜åº¦
				const indoorSize = 100; // å®¤å…§å€åŸŸå¤§å°
				const outdoorSize = 100; // æˆ¶å¤–å€åŸŸå¤§å°

				// ========== å‰µå»ºå¤©ç©ºç›’ (æˆ¶å¤–èƒŒæ™¯) ==========
				createSkybox();

				// ========== å®¤å…§å€åŸŸ (B1 å¯†å®¤) ==========
				// å®¤å…§é‡‘å±¬åœ°æ¿
				metalTexture.repeat.set(20, 20);
				const indoorFloorGeo = new THREE.PlaneGeometry(indoorSize, indoorSize);
				const indoorFloorMat = new THREE.MeshLambertMaterial({ map: metalTexture });
				const indoorFloor = new THREE.Mesh(indoorFloorGeo, indoorFloorMat);
				indoorFloor.rotation.x = -Math.PI / 2;
				indoorFloor.position.set(0, 0, 0);
				indoorFloor.receiveShadow = true;
				scene.add(indoorFloor);
				// åŠ å…¥åœ°æ¿é™£åˆ—ï¼ˆåªç”¨æ–¼å°„ç·šæª¢æ¸¬ï¼Œä¸å½±éŸ¿ç§»å‹•ï¼‰
				floors.push({ mesh: indoorFloor, box: new THREE.Box3().setFromObject(indoorFloor) });

				// å®¤å…§å¤©èŠ±æ¿ï¼ˆè¦–è¦º + ç¢°æ’ï¼‰
				ceilingTexture.repeat.set(15, 15);
				const indoorCeilingGeo = new THREE.BoxGeometry(indoorSize, 1, indoorSize); // æ”¹ç”¨Boxæœ‰åšåº¦
				const indoorCeilingMat = new THREE.MeshLambertMaterial({ map: ceilingTexture });
				const indoorCeiling = new THREE.Mesh(indoorCeilingGeo, indoorCeilingMat);
				indoorCeiling.position.set(0, ceilingHeight + 0.5, 0);
				scene.add(indoorCeiling);
				// åŠ å…¥ç¢°æ’æª¢æ¸¬
				walls.push({ mesh: indoorCeiling, box: new THREE.Box3().setFromObject(indoorCeiling) });

				// å®¤å…§ç‰†å£ (ä¸‰é¢å°é–‰ï¼Œä¸€é¢æœ‰å‡ºå£é€šå¾€æˆ¶å¤–)
				createWall(0, ceilingHeight / 2, -50, 100, ceilingHeight, 1, 'brick', [25, 2]); // å¾Œç‰†
				createWall(-50, ceilingHeight / 2, 0, 1, ceilingHeight, 100, 'brick', [25, 2]); // å·¦ç‰†
				createWall(50, ceilingHeight / 2, 0, 1, ceilingHeight, 100, 'brick', [25, 2]); // å³ç‰†
				// å‰ç‰†æœ‰å‡ºå£ (å…©æ®µç‰† + ä¸­é–“ç©ºæ´)
				createWall(-35, ceilingHeight / 2, 50, 30, ceilingHeight, 1, 'brick', [8, 2]);
				createWall(35, ceilingHeight / 2, 50, 30, ceilingHeight, 1, 'brick', [8, 2]);
				// å‡ºå£ä¸Šæ–¹
				createWall(0, ceilingHeight - 3, 50, 40, 6, 1, 'brick', [10, 1]);

				// å®¤å…§çµæ§‹
				createWall(20, 4, 20, 15, 8, 1, 'brick', [4, 1]);
				createWall(20, 4, -20, 15, 8, 1, 'brick', [4, 1]);
				createWall(-20, 4, 20, 15, 8, 1, 'brick', [4, 1]);
				createWall(-20, 4, -20, 15, 8, 1, 'brick', [4, 1]);
				createWall(35, 4, 0, 1, 8, 25, 'brick', [6, 1]);
				createWall(-35, 4, 0, 1, 8, 25, 'brick', [6, 1]);
				createWall(0, 4, -35, 25, 8, 1, 'brick', [6, 1]);

				// ä¸­å¤®æŸ±å­
				createWall(0, ceilingHeight / 2, 0, 4, ceilingHeight, 4, 'brick', [1, 2]);

				// å®¤å…§ç®±å­
				createCrate(15, 1.5, 0, 3, 3, 3);
				createCrate(-15, 1.5, 0, 3, 3, 3);
				createCrate(0, 1.5, -15, 3, 3, 3);
				createCrate(30, 1, -30, 2, 2, 2);
				createCrate(30, 3, -30, 2, 2, 2);
				createCrate(-30, 1, -30, 2, 2, 2);

				// å®¤å…§é«˜å°
				createCrate(20, 6, 0, 6, 1, 6);
				createCrate(-20, 6, 0, 6, 1, 6);
				createCrate(0, 6, -20, 6, 1, 6);

				// ========== å®¤å…§å±‹é ‚ (å¯¦å¿ƒå°é ‚ï¼Œå¾å¤–é¢çœ‹æ˜¯å»ºç¯‰ç‰©) ==========
				// å±‹é ‚å¹³å° - å¯ä»¥ç«™ä¸Šå»
				const roofTex = createTexture('brick');
				roofTex.repeat.set(20, 20);
				const roofGeo = new THREE.BoxGeometry(100, 2, 100);
				const roofMat = new THREE.MeshLambertMaterial({ map: roofTex });
				const roof = new THREE.Mesh(roofGeo, roofMat);
				roof.position.set(0, ceilingHeight + 1, 0); // å¤©èŠ±æ¿ä¸Šæ–¹
				roof.castShadow = true;
				roof.receiveShadow = true;
				scene.add(roof);
				// å±‹é ‚ç”¨ floors é™£åˆ—ï¼ˆå¯ç«™ç«‹+å°„ç·šæª¢æ¸¬ï¼Œä¸æ“‹XZç§»å‹•ï¼‰
				floors.push({ mesh: roof, box: new THREE.Box3().setFromObject(roof) });

				// å±‹é ‚è­·æ¬„ (å››å‘¨çŸ®ç‰†)
				const roofFenceH = 1.5;
				createWall(0, ceilingHeight + 2 + roofFenceH / 2, -49, 100, roofFenceH, 1, 'brick', [25, 1]);
				createWall(0, ceilingHeight + 2 + roofFenceH / 2, 49, 100, roofFenceH, 1, 'brick', [25, 1]);
				createWall(-49, ceilingHeight + 2 + roofFenceH / 2, 0, 1, roofFenceH, 100, 'brick', [25, 1]);
				createWall(49, ceilingHeight + 2 + roofFenceH / 2, 0, 1, roofFenceH, 100, 'brick', [25, 1]);

				// ========== æˆ¶å¤–å€åŸŸ ==========
				// æˆ¶å¤–è‰åœ°
				const grassTex = createGrassTexture();
				grassTex.repeat.set(20, 20);
				const outdoorFloorGeo = new THREE.PlaneGeometry(outdoorSize, outdoorSize);
				const outdoorFloorMat = new THREE.MeshLambertMaterial({ map: grassTex });
				const outdoorFloor = new THREE.Mesh(outdoorFloorGeo, outdoorFloorMat);
				outdoorFloor.rotation.x = -Math.PI / 2;
				outdoorFloor.position.set(0, 0, 100); // æˆ¶å¤–åœ¨ Z+ æ–¹å‘
				outdoorFloor.receiveShadow = true;
				scene.add(outdoorFloor);
				// åŠ å…¥åœ°æ¿é™£åˆ—ï¼ˆåªç”¨æ–¼å°„ç·šæª¢æ¸¬ï¼Œä¸å½±éŸ¿ç§»å‹•ï¼‰
				floors.push({ mesh: outdoorFloor, box: new THREE.Box3().setFromObject(outdoorFloor) });

				// æˆ¶å¤–åœç‰† (åŠ é«˜åˆ°èƒ½åŒ…åœå±‹é ‚æ–œå¡)
				const fenceHeight = 30;
				createWall(0, fenceHeight / 2, 150, 100, fenceHeight, 1, 'brick', [25, 3]); // é ç«¯ç‰†
				createWall(-50, fenceHeight / 2, 100, 1, fenceHeight, 100, 'brick', [25, 3]); // å·¦ç‰†
				createWall(50, fenceHeight / 2, 100, 1, fenceHeight, 100, 'brick', [25, 3]); // å³ç‰†

				// ========== æ–œå¡é€šå¾€å±‹é ‚ ==========
				// æ–œå¡ï¼šå¾åœ°é¢(y=0, z=60)åˆ°å±‹é ‚(y=22, z=50)
				// æ–œå¡å¾ z=90 é–‹å§‹å¾€å®¤å…§æ–¹å‘çˆ¬å‡åˆ° z=50 (å±‹é ‚é‚Šç·£)
				createRamp(-40, 90, ceilingHeight + 2); // å·¦å´æ–œå¡

				// æˆ¶å¤–è£é£¾ - å²©çŸ³
				createRock(-30, 100);
				createRock(25, 120);
				createRock(-15, 135);
				createRock(35, 90);

				// æˆ¶å¤–ç®±å­
				createCrate(0, 1.5, 80, 3, 3, 3);
				createCrate(-20, 1.5, 110, 3, 3, 3);
				createCrate(20, 1.5, 130, 3, 3, 3);

				// æˆ¶å¤–é«˜å° - ç­æœ›å¡”
				createCrate(0, 3, 120, 4, 6, 4);
				createCrate(0, 7, 120, 6, 1, 6);

				// å±‹é ‚ä¼‘æ¯å€
				createCrate(0, ceilingHeight + 3.5, 0, 8, 1, 8); // å±‹é ‚ä¸­å¤®å¹³å°
				createCrate(30, ceilingHeight + 3.5, -30, 5, 1, 5); // å±‹é ‚è§’è½å¹³å°

				// ========== é†«ç™‚ç®± (2F å±‹é ‚å€åŸŸ) ==========
				createHealthBox(-30, ceilingHeight + 3.5, 20); // å±‹é ‚å·¦å´
				createHealthBox(35, ceilingHeight + 3.5, 20); // å±‹é ‚å³å´
				createHealthBox(0, ceilingHeight + 3.5, -35); // å±‹é ‚å¾Œæ–¹

				// ========== å½ˆè·³å€ (å¢åŠ åˆ°16å€‹) ==========
				const jumpPadPositions = [
					// å®¤å…§
					[25, 25],
					[-25, 25],
					[25, -25],
					[-25, -25],
					[40, 0],
					[-40, 0],
					[0, -40],
					[10, 35],
					[-10, 35], // å‡ºå£é™„è¿‘
					// æˆ¶å¤–
					[0, 70],
					[30, 100],
					[-30, 100],
					[0, 130],
					[40, 130],
					[-40, 130],
					[0, 100], // ä¸­å¤®
				];
				jumpPadPositions.forEach(([x, z]) => createJumpPad(x, z));

				// ========== å‚·å®³å€ (æ¸›å°‘åˆ°4å€‹ï¼Œéš¨æ©Ÿä½ç½®) ==========
				spawnRandomDamageZones();

				// å²©æ¼¿æ± åªä¿ç•™2å€‹åœ¨å®¤å…§è§’è½
				const lavaGeo = new THREE.PlaneGeometry(6, 6);
				const lavaMat = new THREE.MeshBasicMaterial({ color: 0xff2200 });
				[
					[-40, -40],
					[40, -40],
				].forEach(([x, z]) => {
					const lava = new THREE.Mesh(lavaGeo, lavaMat);
					lava.rotation.x = -Math.PI / 2;
					lava.position.set(x, 0.01, z);
					scene.add(lava);
					const lavaLight = new THREE.PointLight(0xff4400, 0.8, 15);
					lavaLight.position.set(x, 1, z);
					scene.add(lavaLight);
					damageZones.push({ x: x, z: z, radius: 4, damage: 3, type: 'lava' });
				});

				// æˆ¶å¤–é™½å…‰
				const sunLight = new THREE.DirectionalLight(0xffffcc, 1);
				sunLight.position.set(50, 100, 150);
				sunLight.castShadow = true;
				scene.add(sunLight);
			}

			// å‰µå»ºå¤©ç©ºç›’ - æ˜äº®çš„ç™½å¤©æ•ˆæœ
			function createSkybox() {
				// ç›´æ¥ç”¨ç´”ç™½è‰²å¤©ç©º
				const skyGeo = new THREE.SphereGeometry(500, 32, 32);
				const skyMat = new THREE.MeshBasicMaterial({
					color: 0xffffff, // ç´”ç™½è‰²
					side: THREE.BackSide, // å…§å´å¯è¦‹
				});
				const sky = new THREE.Mesh(skyGeo, skyMat);
				scene.add(sky);
			}

			// å‰µå»ºè‰åœ°è²¼åœ–
			function createGrassTexture() {
				const canvas = document.createElement('canvas');
				canvas.width = 256;
				canvas.height = 256;
				const ctx = canvas.getContext('2d');

				// åŸºåº•ç¶ è‰²
				ctx.fillStyle = '#3a7a30';
				ctx.fillRect(0, 0, 256, 256);

				// æ·»åŠ è‰çš„ç´‹ç†
				for (let i = 0; i < 500; i++) {
					const x = Math.random() * 256;
					const y = Math.random() * 256;
					const shade = 0.7 + Math.random() * 0.6;
					ctx.fillStyle = `rgb(${Math.floor(50 * shade)}, ${Math.floor(130 * shade)}, ${Math.floor(
						40 * shade
					)})`;
					ctx.fillRect(x, y, 2, 4 + Math.random() * 4);
				}

				// ä¸€äº›æ·±è‰²æ–‘é»
				for (let i = 0; i < 50; i++) {
					ctx.fillStyle = `rgba(20, 60, 20, ${0.3 + Math.random() * 0.3})`;
					ctx.beginPath();
					ctx.arc(Math.random() * 256, Math.random() * 256, 3 + Math.random() * 8, 0, Math.PI * 2);
					ctx.fill();
				}

				const tex = new THREE.CanvasTexture(canvas);
				tex.wrapS = THREE.RepeatWrapping;
				tex.wrapT = THREE.RepeatWrapping;
				return tex;
			}

			// å‰µå»ºæˆ¶å¤–å²©çŸ³
			function createRock(x, z) {
				const rockGeo = new THREE.DodecahedronGeometry(2 + Math.random() * 2, 1);
				const rockMat = new THREE.MeshLambertMaterial({ color: 0x666666 });
				const rock = new THREE.Mesh(rockGeo, rockMat);
				rock.position.set(x, 1, z);
				rock.rotation.set(Math.random(), Math.random(), Math.random());
				rock.scale.set(1, 0.6 + Math.random() * 0.4, 1);
				rock.castShadow = true;
				scene.add(rock);
				walls.push({ mesh: rock, box: new THREE.Box3().setFromObject(rock) });
			}

			// å‰µå»ºæ–œå¡é€šå¾€å±‹é ‚ - ä½¿ç”¨è¦–è¦ºæ–œå¡ + é‚è¼¯é«˜åº¦å€
			function createRamp(x, startZ, targetHeight) {
				const rampWidth = 10; // æ–œå¡å¯¬åº¦
				const rampLength = 40; // æ–œå¡é•·åº¦ï¼ˆç¸®çŸ­è®“å¡åº¦åˆç†ï¼‰
				const endZ = startZ - rampLength;

				// è¦–è¦ºæ–œå¡ - ç”¨ BoxGeometry æ—‹è½‰
				const rampThickness = 1;
				const rampDiagonal = Math.sqrt(rampLength * rampLength + targetHeight * targetHeight);
				const rampGeo = new THREE.BoxGeometry(rampWidth, rampThickness, rampDiagonal);
				const rampTex = createTexture('brick');
				rampTex.repeat.set(2, 10);
				const rampMat = new THREE.MeshLambertMaterial({ map: rampTex });
				const rampMesh = new THREE.Mesh(rampGeo, rampMat);

				// è¨ˆç®—è§’åº¦å’Œä½ç½®
				// æ–œå¡å¾ startZ (ä½ç«¯y=0) å¾€ endZ (é«˜ç«¯y=targetHeight) ä¸Šå‡
				// è§’åº¦ç‚ºæ­£è¡¨ç¤º Z æ¸›å°‘æ™‚ Y å¢åŠ 
				const angle = Math.atan2(targetHeight, rampLength);
				rampMesh.rotation.x = angle; // æ­£è§’åº¦ï¼šZæ¸›å°‘æ™‚Yå¢åŠ 
				rampMesh.position.set(x, targetHeight / 2, (startZ + endZ) / 2);
				rampMesh.castShadow = true;
				rampMesh.receiveShadow = true;
				scene.add(rampMesh);

				// æ–œå¡ç”¨æ–¼å°„ç·šæª¢æ¸¬ï¼ˆå­å½ˆå¯ä»¥æ‰“åˆ°ï¼‰
				floors.push({ mesh: rampMesh, box: new THREE.Box3().setFromObject(rampMesh) });

				// è¨»å†Šæ–œå¡é‚è¼¯å€åŸŸï¼ˆç”¨æ–¼è¨ˆç®—ç©å®¶è…³ä¸‹é«˜åº¦ï¼‰
				ramps.push({
					x: x,
					z1: startZ, // æ–œå¡èµ·é» (ä½ç«¯, y=0)
					z2: endZ, // æ–œå¡çµ‚é» (é«˜ç«¯, y=targetHeight)
					width: rampWidth,
					height: targetHeight,
					// è¨ˆç®—æŸå€‹Zä½ç½®çš„é«˜åº¦
					getHeight: function (pz) {
						if (pz > this.z1 || pz < this.z2) return -1; // ä¸åœ¨æ–œå¡ç¯„åœ
						const progress = (this.z1 - pz) / (this.z1 - this.z2);
						return progress * this.height;
					},
				});

				// æ–œå¡å…©å´è­·æ¬„
				const railMat = new THREE.MeshLambertMaterial({ color: 0x666666 });
				const railHeight = 1.5;
				const railGeo = new THREE.BoxGeometry(0.2, railHeight, rampDiagonal);

				const railL = new THREE.Mesh(railGeo, railMat);
				railL.rotation.x = angle; // èˆ‡æ–œå¡åŒæ–¹å‘
				railL.position.set(x - rampWidth / 2 - 0.15, targetHeight / 2 + railHeight / 2, (startZ + endZ) / 2);
				scene.add(railL);

				const railR = new THREE.Mesh(railGeo, railMat);
				railR.rotation.x = angle; // èˆ‡æ–œå¡åŒæ–¹å‘
				railR.position.set(x + rampWidth / 2 + 0.15, targetHeight / 2 + railHeight / 2, (startZ + endZ) / 2);
				scene.add(railR);

				// æ–œå¡åº•éƒ¨ç®­é ­æ¨™è¨˜
				const arrowCanvas = document.createElement('canvas');
				arrowCanvas.width = 64;
				arrowCanvas.height = 64;
				const ctx = arrowCanvas.getContext('2d');
				ctx.fillStyle = '#ffcc00';
				ctx.beginPath();
				ctx.moveTo(32, 5);
				ctx.lineTo(55, 45);
				ctx.lineTo(40, 45);
				ctx.lineTo(40, 60);
				ctx.lineTo(24, 60);
				ctx.lineTo(24, 45);
				ctx.lineTo(9, 45);
				ctx.closePath();
				ctx.fill();

				const arrowTex = new THREE.CanvasTexture(arrowCanvas);
				const arrowMat = new THREE.MeshBasicMaterial({ map: arrowTex, transparent: true });
				const arrowGeo = new THREE.PlaneGeometry(4, 4);
				const arrow = new THREE.Mesh(arrowGeo, arrowMat);
				arrow.rotation.x = -Math.PI / 2;
				arrow.position.set(x, 0.15, startZ + 3);
				scene.add(arrow);
			}

			// ========== é†«ç™‚ç®±ç³»çµ± ==========
			// ç¶ è‰²ç®±å­è²¼åœ–ï¼ˆé¡ä¼¼æœ¨ç®±ä½†ç¶ è‰²ï¼‰
			function createGreenCrateTexture() {
				const canvas = document.createElement('canvas');
				canvas.width = 256;
				canvas.height = 256;
				const ctx = canvas.getContext('2d');

				// ç¶ è‰²åº•
				ctx.fillStyle = '#2a5a2a';
				ctx.fillRect(0, 0, 256, 256);

				// æœ¨æ¿ç´‹è·¯ï¼ˆæ·±ç¶ ï¼‰
				ctx.fillStyle = '#1a4a1a';
				for (let i = 0; i < 6; i++) {
					ctx.fillRect(0, i * 45 + 3, 256, 3);
				}

				// é‚Šæ¡†
				ctx.strokeStyle = '#0a2a0a';
				ctx.lineWidth = 8;
				ctx.strokeRect(10, 10, 236, 236);

				// ç™½è‰²åå­—æ¨™è¨˜
				ctx.fillStyle = '#ffffff';
				ctx.fillRect(113, 60, 30, 136); // è±æ¢
				ctx.fillRect(60, 113, 136, 30); // æ©«æ¢

				const tex = new THREE.CanvasTexture(canvas);
				tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
				return tex;
			}

			// å‰µå»ºé†«ç™‚ç®±ï¼š3x3x3 = 27å€‹å°ç®±å­çµ„æˆçš„é­”è¡“æ–¹å¡Š
			function createHealthBox(x, y, z) {
				const cubeSize = 1; // æ¯å€‹å°ç®±å­å¤§å°
				const gap = 0.05; // å°ç®±å­é–“éš™
				const step = cubeSize + gap;
				const tex = createGreenCrateTexture();

				// 3x3x3 æ’åˆ—
				for (let ix = -1; ix <= 1; ix++) {
					for (let iy = -1; iy <= 1; iy++) {
						for (let iz = -1; iz <= 1; iz++) {
							const geo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
							const mat = new THREE.MeshLambertMaterial({ map: tex.clone() });
							const cube = new THREE.Mesh(geo, mat);

							cube.position.set(x + ix * step, y + iy * step, z + iz * step);
							cube.castShadow = true;
							cube.receiveShadow = true;

							// ä¸­å¿ƒç®±å­ç‰¹æ®Šæ¨™è¨˜
							const isCenter = ix === 0 && iy === 0 && iz === 0;
							cube.userData = {
								isHealthCube: true,
								isCenter: isCenter,
								health: 20,
								parentPos: { x, y, z }, // è¨˜éŒ„æ¯é«”ä½ç½®
							};

							scene.add(cube);
							healthBoxes.push(cube);
							walls.push({ mesh: cube, box: new THREE.Box3().setFromObject(cube), isHealthBox: true });
						}
					}
				}
			}

			// å°ç®±å­è¢«æ“Šä¸­æ™‚çš„è™•ç†ï¼ˆå®Œå…¨è¤‡ç”¨æ¨™é¶é‚è¼¯ï¼‰
			function damageHealthCube(cube, damage) {
				if (!cube.userData || cube.userData.health <= 0) return;

				cube.userData.health -= damage;

				// é–ƒç™½æ•ˆæœ
				const mat = cube.material;
				if (mat && mat.color) {
					const origColor = mat.color.getHex();
					mat.color.setHex(0xffffff);
					setTimeout(() => mat.color.setHex(origColor), 80);
				}

				// æ‰“ç ´äº†
				if (cube.userData.health <= 0) {
					// ä¸­å¿ƒç®±å­æ‰ç´…å¿ƒ
					if (cube.userData.isCenter) {
						const pos = cube.position.clone();
						createHealthPickup(pos.x, pos.y + 1, pos.z);
						createFloatingText('â¤ï¸', window.innerWidth / 2, window.innerHeight / 2 - 50);
						playSound('kill');
					}

					// ç¢è£‚æ•ˆæœï¼
					explodeCube(cube);

					// å¾å ´æ™¯ç§»é™¤
					scene.remove(cube);
					const idx = healthBoxes.indexOf(cube);
					if (idx > -1) healthBoxes.splice(idx, 1);

					// å¾ç‰†å£é™£åˆ—ç§»é™¤
					const wallIdx = walls.findIndex(w => w.mesh === cube);
					if (wallIdx > -1) walls.splice(wallIdx, 1);
				}
			}

			// ç®±å­ç¢è£‚æ•ˆæœ
			function explodeCube(cube) {
				const pos = cube.position.clone();
				const color = 0x2a5a2a; // ç¶ è‰²
				const fragmentCount = 6;

				for (let i = 0; i < fragmentCount; i++) {
					const size = 0.15 + Math.random() * 0.15;
					const fragGeo = new THREE.BoxGeometry(size, size, size);
					const fragMat = new THREE.MeshLambertMaterial({ color: color });
					const frag = new THREE.Mesh(fragGeo, fragMat);
					frag.position.copy(pos);
					frag.userData = {
						velocity: new THREE.Vector3(
							(Math.random() - 0.5) * 0.2,
							Math.random() * 0.15 + 0.05,
							(Math.random() - 0.5) * 0.2
						),
						life: 40,
					};
					scene.add(frag);

					// ç¢ç‰‡å‹•ç•«
					const animateFrag = () => {
						if (frag.userData.life > 0) {
							frag.position.add(frag.userData.velocity);
							frag.userData.velocity.y -= 0.008; // é‡åŠ›
							frag.rotation.x += 0.15;
							frag.rotation.z += 0.1;
							frag.userData.life--;
							frag.material.opacity = frag.userData.life / 40;
							frag.material.transparent = true;
							requestAnimationFrame(animateFrag);
						} else {
							scene.remove(frag);
						}
					};
					animateFrag();
				}

				playSound('hit');
			}

			// å‰µå»ºæ‰è½çš„æ„›å¿ƒ
			function createHealthPickup(x, y, z) {
				const heart = new THREE.Group();

				// æ„›å¿ƒå½¢ç‹€ - ç”¨å…©å€‹çƒé«”å’Œä¸€å€‹éŒé«”çµ„åˆ
				const heartMat = new THREE.MeshLambertMaterial({ color: 0xff0066, emissive: 0x440022 });

				// å·¦åŠçƒ
				const leftSphere = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), heartMat);
				leftSphere.position.set(-0.35, 0.3, 0);
				heart.add(leftSphere);

				// å³åŠçƒ
				const rightSphere = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), heartMat);
				rightSphere.position.set(0.35, 0.3, 0);
				heart.add(rightSphere);

				// ä¸‹æ–¹å°–ç«¯
				const cone = new THREE.Mesh(new THREE.ConeGeometry(0.7, 1.2, 4), heartMat);
				cone.rotation.z = Math.PI;
				cone.position.y = -0.3;
				heart.add(cone);

				heart.position.set(x, y, z);
				heart.userData = {
					isHealthPickup: true,
					floatPhase: Math.random() * Math.PI * 2,
					baseY: y,
				};

				scene.add(heart);
				healthPickups.push(heart);

				// æ‰è½æ™‚çš„ç‰¹æ•ˆ
				playSound('kill');
				createFloatingText('â¤ï¸ HEALTH!', window.innerWidth / 2, window.innerHeight / 2);
			}

			// æ›´æ–°æ„›å¿ƒå‹•ç•«å’Œæ‹¾å–æª¢æ¸¬
			function updateHealthPickups() {
				for (let i = healthPickups.length - 1; i >= 0; i--) {
					const heart = healthPickups[i];

					// æ¼‚æµ®å‹•ç•«
					heart.userData.floatPhase += 0.05;
					heart.position.y = heart.userData.baseY + Math.sin(heart.userData.floatPhase) * 0.3;
					heart.rotation.y += 0.03;

					// æª¢æ¸¬ç©å®¶æ‹¾å–
					const dist = camera.position.distanceTo(heart.position);
					if (dist < 2.5) {
						// è£œæ»¿è¡€ï¼
						player.health = player.maxHealth;
						updateHUD();
						playSound('jump'); // ç”¨è·³èºéŸ³æ•ˆè¡¨ç¤ºæ‹¾å–
						showMessage('HEALTH RESTORED!');
						createFloatingText('+FULL HP', window.innerWidth / 2, window.innerHeight / 2);

						// ç§»é™¤æ„›å¿ƒ
						scene.remove(heart);
						healthPickups.splice(i, 1);
					}
				}
			}

			// ========== æ•µäººç³»çµ± ==========
			let waveNumber = 0; // ç•¶å‰æ³¢æ¬¡
			const maxWaves = 10; // ç¸½æ³¢æ•¸
			let enemiesPerWave = 5; // æ¯æ³¢åŸºç¤æ•µäººæ•¸
			let spawnTimer = null; // æŒçºŒç”Ÿæˆè¨ˆæ™‚å™¨
			let waveEliteCount = 0; // æœ¬æ³¢ç²¾è‹±æ•¸
			let waveBossCount = 0;  // æœ¬æ³¢Bossæ•¸
			let waveKillTarget = 0; // æœ¬æ³¢æ“Šæ®ºç›®æ¨™
			let waveKills = 0;      // æœ¬æ³¢å·²æ“Šæ®ºæ•¸

			// ç”Ÿæˆæ•µäººï¼ˆæ–°æ³¢æ¬¡ï¼‰
			function spawnEnemies() {
				waveNumber++;
				waveEliteCount = 0;
				waveBossCount = 0;
				waveKills = 0; // é‡ç½®æœ¬æ³¢æ“Šæ®ºæ•¸

				// 10æ³¢ç ´é—œæª¢æŸ¥
				if (waveNumber > maxWaves) {
					gameVictory();
					return;
				}

				// è¨ˆç®—æœ¬æ³¢æ•µäººæ•¸é‡ï¼ˆæ¯æ³¢å¢åŠ 2-3å€‹ï¼‰
				const enemyCount = enemiesPerWave + Math.floor(waveNumber * 2.5);

				// è¨­å®šæœ¬æ³¢æ“Šæ®ºç›®æ¨™ï¼ˆæ¯”åˆå§‹æ•µäººæ•¸å¤šä¸€äº›ï¼Œå› ç‚ºæœƒæœ‰è£œå…µï¼‰
				waveKillTarget = enemyCount + Math.floor(waveNumber * 1.5);

				// é¡¯ç¤ºæ³¢æ¬¡è¨Šæ¯
				showMessage(`WAVE ${waveNumber}/${maxWaves} - KILL ${waveKillTarget} ENEMIES!`);

				// ç”Ÿæˆæ•µäºº
				for (let i = 0; i < enemyCount; i++) {
					// å»¶é²ç”Ÿæˆï¼Œè£½é€ æ•µäººé™¸çºŒå‡ºç¾çš„æ•ˆæœ
					setTimeout(() => {
						spawnSingleEnemy();
						updateWaveMarkers();  // æ›´æ–°æ¨™è¨˜
					}, i * 300); // æ¯0.3ç§’ç”Ÿæˆä¸€å€‹
				}

				updateHUD();

				// å•Ÿå‹•æŒçºŒç”Ÿæˆæ©Ÿåˆ¶ï¼ˆæ¯10ç§’è£œå……æ•µäººï¼Œä½†æœ€å¾Œä¸€æ³¢ä¸è£œå……ï¼‰
				if (spawnTimer) clearInterval(spawnTimer);
				if (waveNumber < maxWaves) {
					spawnTimer = setInterval(() => {
						if (gameStarted && !gameOver && enemies.length < 5) {
							// æ•µäººå¤ªå°‘æ™‚è£œå……
							const reinforcements = Math.min(3 + Math.floor(waveNumber / 2), 8);
							showMessage(`+${reinforcements} REINFORCEMENTS!`);
							for (let i = 0; i < reinforcements; i++) {
								setTimeout(() => {
									spawnSingleEnemy();
									updateWaveMarkers();
								}, i * 200);
							}
						}
					}, 10000);
				}
			}

			// æ›´æ–°æ³¢æ¬¡æ¨™è¨˜ï¼ˆç²¾è‹±! Boss*ï¼‰
			function updateWaveMarkers() {
				// çµ±è¨ˆç•¶å‰å ´ä¸Šçš„ç²¾è‹±å’ŒBoss
				let elites = 0, bosses = 0;
				enemies.forEach(e => {
					if (e.userData && e.userData.health > 0) {
						if (e.userData.type === 'elite') elites++;
						if (e.userData.type === 'boss') bosses++;
					}
				});

				let markers = '';
				for (let i = 0; i < elites; i++) markers += '!';
				for (let i = 0; i < bosses; i++) markers += '*';

				document.getElementById('waveMarkers').textContent = markers ? ' ' + markers : '';
			}

			// å‹åˆ©ç•«é¢
			function gameVictory() {
				gameOver = true;
				if (spawnTimer) clearInterval(spawnTimer);

				// æ¸…é™¤æ‰€æœ‰æ•µäºº
				enemies.forEach(e => scene.remove(e));
				enemies = [];
				enemyProjectiles.forEach(p => scene.remove(p));
				enemyProjectiles = [];

				document.exitPointerLock();

				// å‹åˆ©çå‹µ
				const victoryBonus = 5000;
				totalScore += victoryBonus;

				// é¡¯ç¤ºå‹åˆ©ç•«é¢
				const gameOverScreen = document.getElementById('gameOverScreen');
				gameOverScreen.querySelector('h1').textContent = 'ğŸ† VICTORY! ğŸ†';
				gameOverScreen.querySelector('h1').style.color = '#0f0';
				document.getElementById('finalWave').textContent = maxWaves + ' (COMPLETE!)';
				document.getElementById('finalKills').textContent = player.kills;
				document.getElementById('finalScore').textContent = totalScore + ` (+${victoryBonus} BONUS)`;
				gameOverScreen.style.display = 'flex';

				showMessage('CONGRATULATIONS! YOU SURVIVED ALL 10 WAVES!');
				playSound('kill');
				screenShake = 20;
			}

			// ç”Ÿæˆå–®å€‹æ•µäººï¼ˆåœ¨éš¨æ©Ÿä½ç½®ï¼‰
			function spawnSingleEnemy() {
				// éš¨æ©Ÿé¸æ“‡ç”Ÿæˆå€åŸŸ
				const spawnZones = [
					// å®¤å…§è§’è½
					{ x: [-40, -25], z: [-40, -25] },
					{ x: [25, 40], z: [-40, -25] },
					{ x: [-40, -25], z: [25, 40] },
					{ x: [25, 40], z: [25, 40] },
					// æˆ¶å¤–å€åŸŸ
					{ x: [-45, 45], z: [60, 140] },
					{ x: [-45, -30], z: [50, 100] },
					{ x: [30, 45], z: [50, 100] },
				];

				const zone = spawnZones[Math.floor(Math.random() * spawnZones.length)];
				const x = zone.x[0] + Math.random() * (zone.x[1] - zone.x[0]);
				const z = zone.z[0] + Math.random() * (zone.z[1] - zone.z[0]);

				createEnemy(x, 0, z);
			}

			// å‰µå»ºå–®å€‹æ•µäººï¼ˆæ ¹æ“šé›£åº¦èª¿æ•´å±¬æ€§ï¼‰
			function createEnemy(x, y, z) {
				const enemy = new THREE.Group();

				// æ ¹æ“šæ³¢æ¬¡æ±ºå®šæ•µäººé¡å‹
				const enemyType = getEnemyType();

				// èº«é«”å¤§å°æ ¹æ“šé¡å‹èª¿æ•´
				const bodyScale = enemyType.scale;
				const bodyColor = enemyType.color;

				// èº«é«”ï¼ˆæ¨™è¨˜ç‚º bodyï¼Œå‚·å®³ x1ï¼‰
				const bodyGeo = new THREE.CylinderGeometry(0.5 * bodyScale, 0.6 * bodyScale, 1.8 * bodyScale, 8);
				const bodyMat = new THREE.MeshLambertMaterial({ color: bodyColor });
				const body = new THREE.Mesh(bodyGeo, bodyMat);
				body.position.y = 0.9 * bodyScale;
				body.castShadow = true;
				body.userData.isBody = true; // æ¨™è¨˜ç‚ºèº«é«”
				body.userData.damageMultiplier = 1; // èº«é«”å‚·å®³å€ç‡ x1
				enemy.add(body);

				// é ­éƒ¨ï¼ˆæ¨™è¨˜ç‚º headï¼Œå‚·å®³ x3ï¼‰
				const headGeo = new THREE.SphereGeometry(0.35 * bodyScale, 8, 8);
				const headMat = new THREE.MeshLambertMaterial({ color: enemyType.headColor });
				const head = new THREE.Mesh(headGeo, headMat);
				head.position.y = 2.0 * bodyScale;
				head.castShadow = true;
				head.userData.isHead = true; // æ¨™è¨˜ç‚ºé ­éƒ¨
				head.userData.damageMultiplier = 3; // é ­éƒ¨å‚·å®³å€ç‡ x3
				enemy.add(head);

				// çœ¼ç› - é¡è‰²æ ¹æ“šé¡å‹
				const eyeGeo = new THREE.SphereGeometry(0.08 * bodyScale, 6, 6);
				const eyeMat = new THREE.MeshBasicMaterial({ color: enemyType.eyeColor });
				const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
				eyeL.position.set(-0.12 * bodyScale, 2.05 * bodyScale, 0.28 * bodyScale);
				enemy.add(eyeL);
				const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
				eyeR.position.set(0.12 * bodyScale, 2.05 * bodyScale, 0.28 * bodyScale);
				enemy.add(eyeR);

				// ç²¾è‹±æ•µäººåŠ è£é£¾ï¼ˆè§’æˆ–å…‰ç’°ï¼‰
				if (enemyType.type === 'elite' || enemyType.type === 'boss') {
					// é ­ä¸Šçš„è§’
					const hornGeo = new THREE.ConeGeometry(0.1, 0.4, 4);
					const hornMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
					const hornL = new THREE.Mesh(hornGeo, hornMat);
					hornL.position.set(-0.2, 2.4 * bodyScale, 0);
					hornL.rotation.z = 0.3;
					enemy.add(hornL);
					const hornR = new THREE.Mesh(hornGeo, hornMat);
					hornR.position.set(0.2, 2.4 * bodyScale, 0);
					hornR.rotation.z = -0.3;
					enemy.add(hornR);
				}

				if (enemyType.type === 'boss') {
					// Boss æœ‰å…‰ç’°
					const ringGeo = new THREE.TorusGeometry(1, 0.05, 8, 16);
					const ringMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
					const ring = new THREE.Mesh(ringGeo, ringMat);
					ring.position.y = 2.5 * bodyScale;
					ring.rotation.x = Math.PI / 2;
					enemy.add(ring);
				}

				enemy.position.set(x, y, z);

				// æ ¹æ“šæ³¢æ¬¡å’Œé¡å‹è¨­å®šå±¬æ€§
				const baseHealth = 80 + waveNumber * 15;
				const baseSpeed = 0.05 + waveNumber * 0.005;
				const baseDamage = 8 + waveNumber * 2;

				enemy.userData = {
					health: Math.floor(baseHealth * enemyType.healthMult),
					maxHealth: Math.floor(baseHealth * enemyType.healthMult),
					speed: Math.min(baseSpeed * enemyType.speedMult + Math.random() * 0.02, 0.2),
					baseSpeed: Math.min(baseSpeed * enemyType.speedMult + Math.random() * 0.02, 0.2),
					damage: Math.floor(baseDamage * enemyType.damageMult),
					lastAttack: 0,
					lastRangedAttack: 0,  // é ç¨‹æ”»æ“Šå†·å»
					lastDash: 0,          // Boss è¡åˆºå†·å»
					isDashing: false,     // Boss è¡åˆºä¸­
					dashTarget: null,     // è¡åˆºç›®æ¨™ä½ç½®
					isEnemy: true,
					type: enemyType.type,
					scale: bodyScale,
					points: enemyType.points,
				};

				scene.add(enemy);
				enemies.push(enemy);

				// ç”Ÿæˆç‰¹æ•ˆ
				createSpawnEffect(x, z);
			}

			// æ ¹æ“šæ³¢æ¬¡æ±ºå®šæ•µäººé¡å‹
			function getEnemyType() {
				const rand = Math.random();

				// æ³¢æ¬¡è¶Šé«˜ï¼Œç²¾è‹±å’ŒBosså‡ºç¾æ©Ÿç‡è¶Šé«˜
				const eliteChance = Math.min(0.1 + waveNumber * 0.05, 0.4);
				const bossChance = waveNumber >= 3 ? Math.min(0.02 + waveNumber * 0.02, 0.15) : 0;

				if (rand < bossChance) {
					// Boss - ç´«è‰²å¤§å‹æ•µäºº
					return {
						type: 'boss',
						color: 0x8800aa,
						headColor: 0xcc66ff,
						eyeColor: 0xff0000,
						scale: 1.5,
						healthMult: 4,
						speedMult: 0.7,
						damageMult: 3,
						points: 200,
					};
				} else if (rand < bossChance + eliteChance) {
					// ç²¾è‹± - æ©™è‰²å¼·åŒ–æ•µäºº
					return {
						type: 'elite',
						color: 0xff6600,
						headColor: 0xffaa44,
						eyeColor: 0x00ffff,
						scale: 1.2,
						healthMult: 2,
						speedMult: 1.3,
						damageMult: 1.5,
						points: 100,
					};
				} else {
					// æ™®é€šæ•µäºº - ç´…è‰²
					return {
						type: 'normal',
						color: 0xcc2222,
						headColor: 0xffaaaa,
						eyeColor: 0xffff00,
						scale: 1.0,
						healthMult: 1,
						speedMult: 1,
						damageMult: 1,
						points: 50,
					};
				}
			}

			// æ•µäººç”Ÿæˆç‰¹æ•ˆ
			function createSpawnEffect(x, z) {
				const particles = [];
				for (let i = 0; i < 10; i++) {
					const geo = new THREE.SphereGeometry(0.1, 4, 4);
					const mat = new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true });
					const particle = new THREE.Mesh(geo, mat);
					particle.position.set(x, 0.5, z);
					particle.userData = {
						vx: (Math.random() - 0.5) * 0.2,
						vy: Math.random() * 0.2,
						vz: (Math.random() - 0.5) * 0.2,
						life: 30,
					};
					scene.add(particle);
					particles.push(particle);
				}

				const animateSpawn = () => {
					let alive = false;
					particles.forEach(p => {
						if (p.userData.life > 0) {
							alive = true;
							p.position.x += p.userData.vx;
							p.position.y += p.userData.vy;
							p.position.z += p.userData.vz;
							p.userData.vy -= 0.01;
							p.userData.life--;
							p.material.opacity = p.userData.life / 30;
							if (p.userData.life <= 0) scene.remove(p);
						}
					});
					if (alive) requestAnimationFrame(animateSpawn);
				};
				animateSpawn();
			}

			// æ›´æ–°æ•µäººï¼ˆAIè¡Œç‚ºï¼‰
			function updateEnemies() {
				// Debugæ¨¡å¼ä¸‹æ•µäººæš«åœ
				if (debugMode) return;

				const now = Date.now();

				enemies.forEach(enemy => {
					if (!enemy.userData || enemy.userData.health <= 0) return;

					// è¨ˆç®—åˆ°ç©å®¶çš„æ–¹å‘ï¼ˆæ°´å¹³é¢ï¼‰
					const dir = new THREE.Vector3();
					dir.subVectors(camera.position, enemy.position);
					dir.y = 0; // åªåœ¨æ°´å¹³é¢ç§»å‹•
					const horizDist = dir.length(); // æ°´å¹³è·é›¢ï¼ˆç”¨æ–¼ç§»å‹•ï¼‰
					dir.normalize();

					// è¨ˆç®—çœŸæ­£çš„3Dè·é›¢ï¼ˆç”¨æ–¼æ”»æ“Šåˆ¤å®šï¼‰
					const realDist = camera.position.distanceTo(enemy.position);

					// é¢å‘ç©å®¶
					enemy.lookAt(camera.position.x, enemy.position.y, camera.position.z);

					const enemyType = enemy.userData.type;

					// ========== Boss è¡åˆºé‚è¼¯ ==========
					if (enemyType === 'boss') {
						// è¡åˆºä¸­
						if (enemy.userData.isDashing) {
							const dashSpeed = 24 * deltaTime;  // 0.4 Ã— 60 = 24 æ¯ç§’
							const dashDir = enemy.userData.dashTarget.clone().sub(enemy.position);
							dashDir.y = 0;
							const dashDist = dashDir.length();

							if (dashDist > 1) {
								dashDir.normalize();
								enemy.position.x += dashDir.x * dashSpeed;
								enemy.position.z += dashDir.z * dashSpeed;

								// è¡åˆºä¸­ç¢°åˆ°ç©å®¶é€ æˆå¤§å‚·å®³
								if (realDist < 2) {
									player.health -= enemy.userData.damage * 2;
									showDamage();
									updateHUD();
									createFloatingText('DASH HIT! -' + (enemy.userData.damage * 2), window.innerWidth / 2, window.innerHeight / 2);
									enemy.userData.isDashing = false;
									screenShake = 10;
									if (player.health <= 0) endGame();
								}
							} else {
								// åˆ°é”ç›®æ¨™ï¼ŒçµæŸè¡åˆº
								enemy.userData.isDashing = false;
								enemy.userData.speed = enemy.userData.baseSpeed;
							}
						}
						// ç™¼å‹•è¡åˆºï¼ˆè·é›¢8-20ï¼Œå†·å»5ç§’ï¼‰
						else if (horizDist > 8 && horizDist < 20 && now - enemy.userData.lastDash > 5000) {
							enemy.userData.isDashing = true;
							enemy.userData.dashTarget = camera.position.clone();
							enemy.userData.lastDash = now;
							createFloatingText('âš¡ BOSS DASH!', window.innerWidth / 2, window.innerHeight / 2 - 100);
							playSound('jump');
						}
					}

					// ========== é ç¨‹æ”»æ“Šé‚è¼¯ ==========
					// ç²¾è‹±ï¼šä¸ŸçŸ³é ­ï¼ˆè·é›¢ 8-25ï¼Œå†·å» 3 ç§’ï¼‰
					if (enemyType === 'elite' && horizDist > 8 && horizDist < 25) {
						if (now - enemy.userData.lastRangedAttack > 3000) {
							enemy.userData.lastRangedAttack = now;
							createEnemyProjectile(enemy, 'rock');
						}
					}
					// Bossï¼šç«çƒè¡“ï¼ˆè·é›¢ 5-30ï¼Œå†·å» 2 ç§’ï¼‰
					if (enemyType === 'boss' && !enemy.userData.isDashing && horizDist > 5 && horizDist < 30) {
						if (now - enemy.userData.lastRangedAttack > 2000) {
							enemy.userData.lastRangedAttack = now;
							createEnemyProjectile(enemy, 'fireball');
						}
					}

					// ========== æ™®é€šç§»å‹•é‚è¼¯ ==========
					if (!enemy.userData.isDashing) {
						if (horizDist > 2.5) {
							const moveSpeed = enemy.userData.speed * deltaTime * TARGET_FPS;
							const newX = enemy.position.x + dir.x * moveSpeed;
							const newZ = enemy.position.z + dir.z * moveSpeed;

							// ç°¡æ˜“ç¢°æ’æª¢æ¸¬
							let canMove = true;
							const enemyBox = new THREE.Box3(
								new THREE.Vector3(newX - 0.5, 0, newZ - 0.5),
								new THREE.Vector3(newX + 0.5, 2, newZ + 0.5)
							);

							walls.forEach(w => {
								if (enemyBox.intersectsBox(w.box)) canMove = false;
							});

							// é¿å…æ•µäººäº’ç›¸é‡ç–Š
							enemies.forEach(other => {
								if (other !== enemy && other.userData.health > 0) {
									const d = enemy.position.distanceTo(other.position);
									if (d < 1.5) canMove = false;
								}
							});

							if (canMove) {
								enemy.position.x = newX;
								enemy.position.z = newZ;
							}
						} else if (realDist < 3) {
							// è¿‘è·é›¢æ”»æ“Šç©å®¶ï¼ˆç”¨çœŸæ­£3Dè·é›¢ï¼é¿å…2Fè¢«1Fæ•µäººæ‰“åˆ°ï¼‰
							if (now - enemy.userData.lastAttack > 1000) {
								enemy.userData.lastAttack = now;
								player.health -= enemy.userData.damage;
								showDamage();
								updateHUD();
								createFloatingText(
									`-${enemy.userData.damage}`,
									window.innerWidth / 2,
									window.innerHeight / 2
								);

								if (player.health <= 0) {
									endGame();
								}
							}
						}
					}

					// æ•µäººç°¡å–®å‹•ç•« - ä¸Šä¸‹æµ®å‹•ï¼ˆè¡åˆºä¸­ä¸æµ®å‹•ï¼‰
					if (!enemy.userData.isDashing) {
						enemy.position.y = Math.sin(now * 0.003 + enemy.position.x) * 0.1;
					}
				});
			}

			// å‰µå»ºæ•µäººæŠ•å°„ç‰©
			function createEnemyProjectile(enemy, type) {
				const pos = enemy.position.clone();
				pos.y += 1.5;  // å¾é ­éƒ¨ä½ç½®ç™¼å°„

				let projectile;
				if (type === 'rock') {
					// çŸ³é ­ - ç°è‰²æ–¹å¡Šï¼Œæ‹‹ç‰©ç·š
					const geo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
					const mat = new THREE.MeshLambertMaterial({ color: 0x666666 });
					projectile = new THREE.Mesh(geo, mat);

					// è¨ˆç®—æ‹‹ç‰©ç·šåˆé€Ÿåº¦
					const targetPos = camera.position.clone();
					const dx = targetPos.x - pos.x;
					const dz = targetPos.z - pos.z;
					const dist = Math.sqrt(dx * dx + dz * dz);
					const speed = 0.25;
					const vy = 0.15 + dist * 0.01;  // æ ¹æ“šè·é›¢èª¿æ•´æ‹‹å°„è§’åº¦

					projectile.userData = {
						type: 'rock',
						velocity: new THREE.Vector3(dx / dist * speed, vy, dz / dist * speed),
						damage: enemy.userData.damage,
						life: 180
					};
				} else if (type === 'fireball') {
					// ç«çƒ - ç´…è‰²çƒé«”ï¼Œè¿½è¹¤ç©å®¶
					const geo = new THREE.SphereGeometry(0.3, 8, 8);
					const mat = new THREE.MeshBasicMaterial({ color: 0xff4400 });
					projectile = new THREE.Mesh(geo, mat);

					// åŠ å…¥å…‰æšˆæ•ˆæœ
					const glowGeo = new THREE.SphereGeometry(0.5, 8, 8);
					const glowMat = new THREE.MeshBasicMaterial({
						color: 0xff8800,
						transparent: true,
						opacity: 0.4
					});
					const glow = new THREE.Mesh(glowGeo, glowMat);
					projectile.add(glow);

					projectile.userData = {
						type: 'fireball',
						speed: 0.15,
						turnRate: 0.02,  // è¿½è¹¤è½‰å‘ç‡
						damage: enemy.userData.damage * 1.5,
						life: 300
					};
				}

				projectile.position.copy(pos);
				scene.add(projectile);
				enemyProjectiles.push(projectile);

				// éŸ³æ•ˆ
				playSound('reload');
			}

			// æ›´æ–°æ•µäººæŠ•å°„ç‰©
			function updateEnemyProjectiles() {
				for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
					const proj = enemyProjectiles[i];
					proj.userData.life--;

					if (proj.userData.life <= 0) {
						scene.remove(proj);
						enemyProjectiles.splice(i, 1);
						continue;
					}

					if (proj.userData.type === 'rock') {
						// çŸ³é ­ï¼šæ‹‹ç‰©ç·šé‹å‹• - deltaTime æ¨™æº–åŒ–
						const moveVec = proj.userData.velocity.clone().multiplyScalar(deltaTime * TARGET_FPS);
						proj.position.add(moveVec);
						proj.userData.velocity.y -= 0.48 * deltaTime;  // 0.008 Ã— 60 = 0.48 æ¯ç§’
						proj.rotation.x += 6 * deltaTime;   // 0.1 Ã— 60
						proj.rotation.z += 6 * deltaTime;

						// ç¢°åœ°æ¶ˆå¤±
						if (proj.position.y < 0) {
							createBulletImpact(proj.position, new THREE.Vector3(0, 1, 0));
							scene.remove(proj);
							enemyProjectiles.splice(i, 1);
							continue;
						}
					} else if (proj.userData.type === 'fireball') {
						// ç«çƒï¼šè¿½è¹¤ç©å®¶ - deltaTime æ¨™æº–åŒ–
						const toPlayer = camera.position.clone().sub(proj.position);
						toPlayer.normalize();

						// ç·©æ…¢è½‰å‘ç©å®¶
						const currentDir = proj.userData.velocity || toPlayer.clone().multiplyScalar(proj.userData.speed);
						const lerpFactor = Math.min(proj.userData.turnRate * deltaTime * TARGET_FPS, 1);
						currentDir.lerp(toPlayer.multiplyScalar(proj.userData.speed), lerpFactor);
						proj.userData.velocity = currentDir;

						const moveVec = currentDir.clone().multiplyScalar(deltaTime * TARGET_FPS);
						proj.position.add(moveVec);

						// ç«çƒæ—‹è½‰
						proj.rotation.y += 6 * deltaTime;  // 0.1 Ã— 60
					}

					// æª¢æ¸¬ç¢°æ’ç©å®¶
					const distToPlayer = proj.position.distanceTo(camera.position);
					if (distToPlayer < 1.5) {
						// å‘½ä¸­ç©å®¶ï¼
						player.health -= proj.userData.damage;
						showDamage();
						updateHUD();
						screenShake = 5;

						const hitType = proj.userData.type === 'rock' ? 'ğŸª¨' : 'ğŸ”¥';
						createFloatingText(`${hitType} -${proj.userData.damage}`, window.innerWidth / 2, window.innerHeight / 2);

						if (proj.userData.type === 'fireball') {
							createExplosion(proj.position, 0.5);
							playSound('explosion');
						} else {
							playSound('hit');
						}

						scene.remove(proj);
						enemyProjectiles.splice(i, 1);

						if (player.health <= 0) endGame();
						continue;
					}

					// æª¢æ¸¬ç¢°æ’ç‰†å£
					let hitWall = false;
					walls.forEach(w => {
						if (w.box.containsPoint(proj.position)) hitWall = true;
					});
					if (hitWall) {
						if (proj.userData.type === 'fireball') {
							createExplosion(proj.position, 0.3);
						}
						scene.remove(proj);
						enemyProjectiles.splice(i, 1);
					}
				}
			}

			// æ•µäººè¢«æ“Šä¸­
			function damageEnemy(enemy, damage) {
				enemy.userData.health -= damage;

				// å—å‚·é–ƒç™½
				enemy.children.forEach(c => {
					if (c.material && c.material.color) {
						const origColor = c.material.color.getHex();
						c.material.color.setHex(0xffffff);
						setTimeout(() => {
							if (c.material) c.material.color.setHex(origColor);
						}, 100);
					}
				});

				if (enemy.userData.health <= 0) {
					// æ•µäººæ­»äº¡
					destroyEnemy(enemy);
				}
			}

			// æ¶ˆæ»…æ•µäºº
			function destroyEnemy(enemy) {
				player.kills++;

				// æ ¹æ“šæ•µäººé¡å‹çµ¦åˆ†
				const points = enemy.userData.points || 50;
				const typeBonus =
					enemy.userData.type === 'boss' ? ' BOSS!' : enemy.userData.type === 'elite' ? ' ELITE!' : '';

				roundScore += points;
				totalScore += points;

				// é€£æ®ºçå‹µ
				const now = Date.now();
				if (now - lastKillTime < 3000) {
					killStreak++;
					const streakBonus = killStreak * 10;
					totalScore += streakBonus;
					if (killStreak >= 3) {
						createFloatingText(
							`+${points} KILL${typeBonus} x${killStreak}!`,
							window.innerWidth / 2,
							window.innerHeight / 2 - 80
						);
					} else {
						createFloatingText(
							`+${points}${typeBonus}`,
							window.innerWidth / 2,
							window.innerHeight / 2 - 80
						);
					}
				} else {
					killStreak = 1;
					createFloatingText(`+${points}${typeBonus}`, window.innerWidth / 2, window.innerHeight / 2 - 80);
				}
				lastKillTime = now;

				// é¡¯ç¤ºé€£æ®º
				if (killStreak >= 3) showKillStreak();

				updateHUD();

				// çˆ†ç‚¸æ•ˆæœï¼ˆBossçˆ†ç‚¸æ›´å¤§ï¼‰
				const explosionScale = enemy.userData.scale || 1;
				for (let i = 0; i < Math.ceil(explosionScale); i++) {
					const offset = new THREE.Vector3(
						(Math.random() - 0.5) * explosionScale,
						Math.random() * explosionScale,
						(Math.random() - 0.5) * explosionScale
					);
					createExplosion(enemy.position.clone().add(offset));
				}
				playSound('explosion');
				if (enemy.userData.type === 'boss') {
					playSound('kill');
					screenShake = 15;
					showMessage('BOSS DEFEATED! +500 BONUS');
					totalScore += 500;
				}

				// ç§»é™¤æ•µäºº
				const idx = enemies.indexOf(enemy);
				if (idx > -1) enemies.splice(idx, 1);
				scene.remove(enemy);

				// æ›´æ–°ç²¾è‹±/Bossæ¨™è¨˜
				updateWaveMarkers();

				// å¢åŠ æœ¬æ³¢æ“Šæ®ºæ•¸
				waveKills++;
				updateHUD();

				// æª¢æŸ¥æ˜¯å¦é”æˆæ“Šæ®ºç›®æ¨™
				if (waveKills >= waveKillTarget) {
					// æ¸…æ³¢çå‹µ
					const waveBonus = 200 + waveNumber * 100;
					totalScore += waveBonus;
					showMessage(`WAVE ${waveNumber}/${maxWaves} CLEARED! +${waveBonus} BONUS`);
					playSound('kill');

					// æ¸…é™¤å‰©é¤˜æ•µäººï¼ˆçµ¦ç©å®¶çŸ­æš«ä¼‘æ¯ï¼‰
					enemies.forEach(e => scene.remove(e));
					enemies = [];

					// åœæ­¢è£œå…µ
					if (spawnTimer) {
						clearInterval(spawnTimer);
						spawnTimer = null;
					}

					// çŸ­æš«ä¼‘æ¯å¾Œç”Ÿæˆä¸‹ä¸€æ³¢
					setTimeout(() => {
						if (gameStarted && !gameOver) {
							spawnEnemies();
						}
					}, 3000);
				}
			}

			// éš¨æ©Ÿç”Ÿæˆå‚·å®³å€ (é¿é–‹å‡ºç”Ÿé»)
			function spawnRandomDamageZones() {
				// æ¸…é™¤èˆŠçš„å‚·å®³å€
				damageZoneMeshes.forEach(mesh => scene.remove(mesh));
				damageZoneMeshes = [];
				// åªä¿ç•™å²©æ¼¿å€
				damageZones = damageZones.filter(z => z.type === 'lava');

				// å¯ç”¨ä½ç½®æ±  (é¿é–‹å‡ºç”Ÿé» 10,1.7,10 é™„è¿‘)
				const possiblePositions = [
					// å®¤å…§
					[-25, -25, 5, 5],
					[25, -25, 5, 5],
					[-30, 10, 5, 5],
					[30, 10, 5, 5],
					// æˆ¶å¤–
					[-20, 90, 5, 5],
					[20, 90, 5, 5],
					[0, 140, 6, 6],
					[-35, 120, 5, 5],
				];

				// éš¨æ©Ÿé¸4å€‹
				const shuffled = possiblePositions.sort(() => Math.random() - 0.5);
				const selected = shuffled.slice(0, 4);

				selected.forEach(([x, z, w, d]) => {
					createDamageZone(x, z, w, d);
				});
			}

			// å‰µå»ºå‚·å®³åœ°æ¿
			function createDamageZone(x, z, w, d) {
				// å‚·å®³åœ°æ¿è¦–è¦ºæ•ˆæœ
				const zoneGeo = new THREE.PlaneGeometry(w, d);

				// å‰µå»ºè­¦å‘Šæ¢ç´‹è²¼åœ–
				const canvas = document.createElement('canvas');
				canvas.width = 64;
				canvas.height = 64;
				const ctx = canvas.getContext('2d');

				// é»‘é»ƒæ¢ç´‹
				ctx.fillStyle = '#220000';
				ctx.fillRect(0, 0, 64, 64);
				ctx.fillStyle = '#ff0000';
				for (let i = 0; i < 8; i++) {
					ctx.fillRect(i * 16, 0, 8, 64);
				}
				// éª·é«æ¨™èªŒ
				ctx.fillStyle = '#ffff00';
				ctx.font = 'bold 30px Arial';
				ctx.textAlign = 'center';
				ctx.fillText('â˜ ', 32, 45);

				const tex = new THREE.CanvasTexture(canvas);
				tex.wrapS = THREE.RepeatWrapping;
				tex.wrapT = THREE.RepeatWrapping;
				tex.repeat.set(w / 4, d / 4);

				const zoneMat = new THREE.MeshBasicMaterial({
					map: tex,
					transparent: true,
					opacity: 0.8,
				});
				const zone = new THREE.Mesh(zoneGeo, zoneMat);
				zone.rotation.x = -Math.PI / 2;
				zone.position.set(x, 0.02, z);
				scene.add(zone);
				damageZoneMeshes.push(zone); // è¿½è¹¤ä»¥ä¾¿é‡ç½®

				// ç´…è‰²è­¦å‘Šå…‰
				const light = new THREE.PointLight(0xff0000, 0.5, 10);
				light.position.set(x, 0.5, z);
				scene.add(light);
				damageZoneMeshes.push(light); // è¿½è¹¤å…‰æº

				// å„²å­˜å‚·å®³å€è³‡è¨Š
				damageZones.push({
					x: x,
					z: z,
					w: w,
					d: d,
					damage: 2,
					type: 'floor',
				});
			}

			// å‰µå»ºåé‡åŠ›å½ˆè·³å€
			function createJumpPad(x, z) {
				const padSize = 3;

				// å½ˆè·³æ¿åŸºåº§
				const baseGeo = new THREE.CylinderGeometry(padSize / 2, padSize / 2 + 0.3, 0.3, 16);
				const baseMat = new THREE.MeshLambertMaterial({ color: 0x333366 });
				const base = new THREE.Mesh(baseGeo, baseMat);
				base.position.set(x, 0.15, z);
				scene.add(base);

				// ç™¼å…‰åœ“ç›¤
				const padGeo = new THREE.CylinderGeometry(padSize / 2 - 0.2, padSize / 2 - 0.2, 0.1, 16);
				const padMat = new THREE.MeshBasicMaterial({
					color: 0x00ffff,
					transparent: true,
					opacity: 0.7,
				});
				const pad = new THREE.Mesh(padGeo, padMat);
				pad.position.set(x, 0.35, z);
				pad.userData = { glowPhase: Math.random() * Math.PI * 2 };
				scene.add(pad);

				// å‘ä¸Šç®­é ­æ¨™èªŒ
				const arrowCanvas = document.createElement('canvas');
				arrowCanvas.width = 64;
				arrowCanvas.height = 64;
				const ctx = arrowCanvas.getContext('2d');
				ctx.fillStyle = '#00ffff';
				ctx.beginPath();
				ctx.moveTo(32, 5);
				ctx.lineTo(55, 40);
				ctx.lineTo(40, 40);
				ctx.lineTo(40, 60);
				ctx.lineTo(24, 60);
				ctx.lineTo(24, 40);
				ctx.lineTo(9, 40);
				ctx.closePath();
				ctx.fill();

				const arrowTex = new THREE.CanvasTexture(arrowCanvas);
				const arrowMat = new THREE.MeshBasicMaterial({
					map: arrowTex,
					transparent: true,
					side: THREE.DoubleSide,
				});
				const arrowGeo = new THREE.PlaneGeometry(1.5, 1.5);
				const arrow = new THREE.Mesh(arrowGeo, arrowMat);
				arrow.rotation.x = -Math.PI / 2;
				arrow.position.set(x, 0.4, z);
				scene.add(arrow);

				// è—è‰²å…‰æº
				const light = new THREE.PointLight(0x00ffff, 1, 8);
				light.position.set(x, 1, z);
				scene.add(light);

				// å„²å­˜å½ˆè·³å€è³‡è¨Š
				jumpPads.push({
					x: x,
					z: z,
					radius: padSize / 2,
					jumpForce: 0.8, // å¼·åŠ›å½ˆè·³
					pad: pad,
					light: light,
				});
			}

			function createWall(x, y, z, w, h, d, texType, repeat) {
				const geo = new THREE.BoxGeometry(w, h, d);
				let mat;

				if (texType === 'brick') {
					const tex = createTexture('brick');
					tex.repeat.set(repeat[0], repeat[1]);
					mat = new THREE.MeshLambertMaterial({ map: tex });
				} else {
					mat = new THREE.MeshLambertMaterial({ color: 0x5a3030 });
				}

				const wall = new THREE.Mesh(geo, mat);
				wall.position.set(x, y, z);
				wall.castShadow = true;
				wall.receiveShadow = true;
				scene.add(wall);
				walls.push({ mesh: wall, box: new THREE.Box3().setFromObject(wall) });
			}

			function createCrate(x, y, z, w, h, d) {
				const geo = new THREE.BoxGeometry(w, h, d);
				const tex = createTexture('crate');
				const mat = new THREE.MeshLambertMaterial({ map: tex });
				const crate = new THREE.Mesh(geo, mat);
				crate.position.set(x, y, z);
				crate.castShadow = true;
				crate.receiveShadow = true;
				scene.add(crate);
				walls.push({ mesh: crate, box: new THREE.Box3().setFromObject(crate) });
			}

			// å‰µå»ºå››é¢åˆ†æ•¸æ¨™é¶çš„è²¼åœ–
			function createTargetFaceTexture(score, color) {
				const canvas = document.createElement('canvas');
				canvas.width = 128;
				canvas.height = 128;
				const ctx = canvas.getContext('2d');

				// èƒŒæ™¯è‰²
				ctx.fillStyle = color;
				ctx.fillRect(0, 0, 128, 128);

				// æ¨™é¶åœ“ç’°
				const rings = score >= 500 ? 4 : score >= 300 ? 3 : score >= 200 ? 2 : 1;
				const ringColors = ['#fff', '#000', '#fff', '#000'];
				for (let i = rings; i >= 0; i--) {
					ctx.fillStyle = ringColors[i % 2];
					ctx.beginPath();
					ctx.arc(64, 64, 50 - i * 10, 0, Math.PI * 2);
					ctx.fill();
				}

				// ä¸­å¿ƒé¶å¿ƒ
				ctx.fillStyle = score >= 500 ? '#FFD700' : score >= 300 ? '#ff0' : score >= 200 ? '#f80' : '#f00';
				ctx.beginPath();
				ctx.arc(64, 64, 15, 0, Math.PI * 2);
				ctx.fill();

				// åˆ†æ•¸æ–‡å­—
				ctx.fillStyle = '#fff';
				ctx.strokeStyle = '#000';
				ctx.lineWidth = 3;
				ctx.font = 'bold 28px Arial';
				ctx.textAlign = 'center';
				ctx.textBaseline = 'middle';
				ctx.strokeText(score.toString(), 64, 64);
				ctx.fillText(score.toString(), 64, 64);

				return new THREE.CanvasTexture(canvas);
			}

			// å‰µå»ºå¯ç ´å£çš„æ¨™é¶ç®±å­ - å››é¢ä¸åŒåˆ†æ•¸
			function createTarget(x, y, z) {
				const target = new THREE.Group();

				// å››å€‹é¢çš„åˆ†æ•¸å’Œé¡è‰²
				const faceScores = [100, 200, 300, 500]; // å‰ã€å³ã€å¾Œã€å·¦
				const faceColors = ['#cc4444', '#44cc44', '#4444cc', '#cccc44'];

				// å‰µå»ºç®±å­çš„å…­å€‹é¢
				const boxSize = 1.5;
				const halfSize = boxSize / 2;

				// ä½¿ç”¨å…­å€‹å¹³é¢çµ„æˆç®±å­ï¼Œæ¯é¢å¯ä»¥æœ‰ä¸åŒè²¼åœ–
				const planeGeo = new THREE.PlaneGeometry(boxSize, boxSize);

				// å‰é¢ (Z+) - 100åˆ†
				const frontTex = createTargetFaceTexture(100, faceColors[0]);
				const frontMat = new THREE.MeshBasicMaterial({ map: frontTex });
				const front = new THREE.Mesh(planeGeo, frontMat);
				front.position.z = halfSize;
				front.userData = { faceIndex: 0, score: 100 };
				target.add(front);

				// å¾Œé¢ (Z-) - 300åˆ†
				const backTex = createTargetFaceTexture(300, faceColors[2]);
				const backMat = new THREE.MeshBasicMaterial({ map: backTex });
				const back = new THREE.Mesh(planeGeo, backMat);
				back.position.z = -halfSize;
				back.rotation.y = Math.PI;
				back.userData = { faceIndex: 2, score: 300 };
				target.add(back);

				// å³é¢ (X+) - 200åˆ†
				const rightTex = createTargetFaceTexture(200, faceColors[1]);
				const rightMat = new THREE.MeshBasicMaterial({ map: rightTex });
				const right = new THREE.Mesh(planeGeo, rightMat);
				right.position.x = halfSize;
				right.rotation.y = Math.PI / 2;
				right.userData = { faceIndex: 1, score: 200 };
				target.add(right);

				// å·¦é¢ (X-) - 500åˆ† (é«˜åˆ†é¢!)
				const leftTex = createTargetFaceTexture(500, faceColors[3]);
				const leftMat = new THREE.MeshBasicMaterial({ map: leftTex });
				const left = new THREE.Mesh(planeGeo, leftMat);
				left.position.x = -halfSize;
				left.rotation.y = -Math.PI / 2;
				left.userData = { faceIndex: 3, score: 500 };
				target.add(left);

				// ä¸Šé¢å’Œä¸‹é¢ - ç”¨ç°¡å–®é¡è‰²
				const topGeo = new THREE.PlaneGeometry(boxSize, boxSize);
				const topMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
				const top = new THREE.Mesh(topGeo, topMat);
				top.position.y = halfSize;
				top.rotation.x = -Math.PI / 2;
				target.add(top);

				const bottom = new THREE.Mesh(topGeo, topMat);
				bottom.position.y = -halfSize;
				bottom.rotation.x = Math.PI / 2;
				target.add(bottom);

				target.position.set(x, y, z);

				// ä¸å®šé€Ÿæ—‹è½‰ï¼šé€Ÿåº¦ç¯„åœå¾æ…¢åˆ°å¿«
				const rotateSpeed = (Math.random() * 0.04 + 0.01) * (Math.random() > 0.5 ? 1 : -1);

				target.userData = {
					health: 30,
					maxHealth: 30,
					isTarget: true,
					baseY: y,
					floatPhase: Math.random() * Math.PI * 2,
					rotateSpeed: rotateSpeed,
					faceScores: faceScores, // å„²å­˜åˆ†æ•¸é™£åˆ—ä¾›è¨ˆåˆ†ç”¨
				};

				scene.add(target);
				targets.push(target);
			}

			// ç”Ÿæˆæ¨™é¶
			function spawnTargets() {
				// æ¸…é™¤èˆŠæ¨™é¶
				targets.forEach(t => scene.remove(t));
				targets = [];

				// åœ¨å®¤å…§å’Œæˆ¶å¤–ç”Ÿæˆæ¨™é¶
				const positions = [
					// å®¤å…§å€åŸŸ
					[20, 1.5, 0],
					[-20, 1.5, 0],
					[0, 1.5, -20],
					[25, 2, 25],
					[-25, 2, 25],
					[25, 2, -25],
					[-25, 2, -25],
					[15, 3, 15],
					[-15, 3, 15],
					[15, 3, -15],
					[-15, 3, -15],
					[30, 1.5, 10],
					[-30, 1.5, 10],
					[30, 1.5, -10],
					[-30, 1.5, -10],
					// æˆ¶å¤–å€åŸŸ
					[0, 1.5, 75],
					[20, 2, 85],
					[-20, 2, 85],
					[30, 1.5, 100],
					[-30, 1.5, 100],
					[0, 2, 100],
					[0, 8, 120], // ç­æœ›å¡”ä¸Š
					[25, 2, 130],
					[-25, 2, 130],
					[0, 1.5, 140],
				];

				const count = Math.min(10 + Math.floor(difficulty * 2), positions.length);
				// éš¨æ©Ÿæ‰“äº‚é †åºå†å–å‰ count å€‹
				const shuffled = positions.sort(() => Math.random() - 0.5);
				for (let i = 0; i < count; i++) {
					const [x, y, z] = shuffled[i];
					createTarget(x, y, z);
				}
			}

			// æ›´æ–°æ¨™é¶å‹•ç•«
			function updateTargets() {
				targets.forEach(target => {
					if (target.userData.health <= 0) return;

					// ä¸Šä¸‹æµ®å‹•
					target.userData.floatPhase += 0.03;
					target.position.y = target.userData.baseY + Math.sin(target.userData.floatPhase) * 0.3;

					// ç·©æ…¢æ—‹è½‰
					target.rotation.y += target.userData.rotateSpeed;
				});
			}

			// æ¨™é¶çˆ†ç‚¸æ•ˆæœ
			function explodeTarget(target) {
				const idx = targets.indexOf(target);
				if (idx > -1) {
					targets.splice(idx, 1);

					// å‰µå»ºç¢ç‰‡
					const fragmentCount = 8;
					const fragments = [];
					const color = target.children[0].material.color.getHex();

					for (let i = 0; i < fragmentCount; i++) {
						const fragGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
						const fragMat = new THREE.MeshLambertMaterial({ color: color });
						const frag = new THREE.Mesh(fragGeo, fragMat);
						frag.position.copy(target.position);
						frag.userData = {
							velocity: new THREE.Vector3(
								(Math.random() - 0.5) * 0.3,
								Math.random() * 0.2 + 0.1,
								(Math.random() - 0.5) * 0.3
							),
							life: 60,
						};
						scene.add(frag);
						fragments.push(frag);
					}

					// ç¢ç‰‡å‹•ç•«
					const animateFragments = () => {
						let allDead = true;
						fragments.forEach(frag => {
							if (frag.userData.life > 0) {
								allDead = false;
								frag.position.add(frag.userData.velocity);
								frag.userData.velocity.y -= 0.01; // é‡åŠ›
								frag.rotation.x += 0.1;
								frag.rotation.z += 0.1;
								frag.userData.life--;

								// æ·¡å‡º
								frag.material.opacity = frag.userData.life / 60;
								frag.material.transparent = true;

								if (frag.userData.life <= 0) {
									scene.remove(frag);
								}
							}
						});
						if (!allDead) {
							requestAnimationFrame(animateFragments);
						}
					};
					animateFragments();

					scene.remove(target);
					playSound('kill');

					player.kills++;
					updateHUD();
	
					// é€£æ®º
					const now = Date.now();
					if (now - lastKillTime < 2000) {
						killStreak++;
					} else {
						killStreak = 1;
					}
					lastKillTime = now;
					showKillStreak();
					createFloatingText(`+${100 * killStreak}`, window.innerWidth / 2, window.innerHeight / 2 - 50);

					showMessage('TARGET DESTROYED!');

					// å…¨éƒ¨æ‰“å®Œï¼Œç”Ÿæˆæ–°ä¸€æ³¢
					if (targets.length === 0) {
						difficulty += 0.5;
						killStreak = 0;
						showMessage(`WAVE COMPLETE! ROUND SCORE: ${roundScore}`);
						roundScore = 0; // é‡ç½®æœ¬è¼ªåˆ†æ•¸
						updateHUD();
						setTimeout(() => spawnTargets(), 2000);
					}
				}
			}

			function setupEvents() {
				// éµç›¤äº‹ä»¶ - ç¶å®šåˆ° window ç¢ºä¿èƒ½æ•ç²
				window.addEventListener('keydown', e => {
					keys[e.code] = true;
					if (e.code === 'KeyR' && gameStarted && !gameOver) reload();
					if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') player.isSprinting = true;
					// æ­¦å™¨åˆ‡æ›
					if (e.code === 'Digit1' && gameStarted && !gameOver) switchWeapon(1);
					if (e.code === 'Digit2' && gameStarted && !gameOver) switchWeapon(2);
					if (e.code === 'Digit3' && gameStarted && !gameOver) switchWeapon(3);
					// Qéµåˆ‡æ›Debugæ¨¡å¼
					if (e.code === 'KeyQ' && gameStarted && !gameOver) {
						debugMode = !debugMode;
						showMessage(debugMode ? 'DEBUG MODE ON - Enemies Paused' : 'DEBUG MODE OFF');
					}
					// é˜²æ­¢æ–¹å‘éµæ²å‹•é é¢
					if (
						[
							'Space',
							'KeyW',
							'KeyA',
							'KeyS',
							'KeyD',
							'ArrowUp',
							'ArrowDown',
							'ArrowLeft',
							'ArrowRight',
						].includes(e.code)
					) {
						e.preventDefault();
					}
				});

				window.addEventListener('keyup', e => {
					keys[e.code] = false;
					if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') player.isSprinting = false;
				});

				document.addEventListener('mousemove', e => {
					if (!isPointerLocked || !gameStarted || gameOver) return;

					// æ›´æ–° yaw å’Œ pitch
					cameraYaw -= e.movementX * 0.002;
					cameraPitch -= e.movementY * 0.002;

					// é™åˆ¶æŠ¬é ­ä½é ­è§’åº¦ (ä¸èƒ½ç¿»è½‰)
					cameraPitch = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, cameraPitch));

					// ç”¨ Euler é †åº 'YXZ' ä¾†æ­£ç¢ºå¥—ç”¨æ—‹è½‰ï¼Œé¿å… roll
					camera.rotation.order = 'YXZ';
					camera.rotation.y = cameraYaw;
					camera.rotation.x = cameraPitch;
					camera.rotation.z = 0; // æ°¸é ä¸æ—‹è½‰ Z è»¸
				});

				document.addEventListener('pointerlockchange', () => {
					isPointerLocked = document.pointerLockElement === renderer.domElement;
				});

				// æ»‘é¼ äº‹ä»¶
				renderer.domElement.addEventListener('mousedown', e => {
					if (!gameStarted || gameOver) return;
					if (!isPointerLocked) {
						renderer.domElement.requestPointerLock();
					} else if (e.button === 0) {
						// å·¦éµå°„æ“Š
						keys['Mouse0'] = true;
						shoot();
					} else if (e.button === 2) {
						// å³éµæ›å½ˆ
						reload();
					}
				});

				renderer.domElement.addEventListener('mouseup', e => {
					if (e.button === 0) keys['Mouse0'] = false;
				});

				// æ»¾è¼ªåˆ‡æ›æ­¦å™¨ï¼ˆæœ‰ debounce é˜²æ­¢æ»¾å¤ªå¿«ï¼‰
				let lastWheelTime = 0;
				const wheelDebounce = 150;  // 150ms å…§åªéŸ¿æ‡‰ä¸€æ¬¡
				renderer.domElement.addEventListener('wheel', e => {
					if (!gameStarted || gameOver) return;
					e.preventDefault();

					const now = Date.now();
					if (now - lastWheelTime < wheelDebounce) return;
					lastWheelTime = now;

					let newWeapon = player.currentWeapon;
					if (e.deltaY > 0) {
						// æ»¾è¼ªä¸‹ â†’ ä¸‹ä¸€æŠŠ (1â†’2â†’3â†’1)
						newWeapon = newWeapon >= 3 ? 1 : newWeapon + 1;
					} else if (e.deltaY < 0) {
						// æ»¾è¼ªä¸Š â†’ ä¸Šä¸€æŠŠ (3â†’2â†’1â†’3)
						newWeapon = newWeapon <= 1 ? 3 : newWeapon - 1;
					}
					switchWeapon(newWeapon);
				}, { passive: false });

				// ç¦ç”¨å³éµé¸å–®
				renderer.domElement.addEventListener('contextmenu', e => {
					e.preventDefault();
				});

				document.getElementById('startBtn').addEventListener('click', startGame);
				document.getElementById('restartBtn').addEventListener('click', restartGame);

				window.addEventListener('resize', () => {
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
					renderer.setSize(window.innerWidth, window.innerHeight);
				});
			}

			function drawWeapon() {
				const canvas = document.getElementById('weapon');
				const ctx = canvas.getContext('2d');
				canvas.width = 350;
				canvas.height = 250;

				// æ­¦å™¨å¾Œåº§åŠ›å‹•ç•«
				const recoilOffset = weaponRecoil * 20;

				ctx.clearRect(0, 0, 350, 250);
				ctx.save();
				ctx.translate(0, recoilOffset);

				// æ‰‹è‡‚
				ctx.fillStyle = '#c4a080';
				ctx.beginPath();
				ctx.moveTo(280, 250);
				ctx.lineTo(320, 180);
				ctx.lineTo(350, 180);
				ctx.lineTo(350, 250);
				ctx.fill();

				if (player.currentWeapon === 1) {
					// SMG è¡é‹’æ§
					// æ§èº«ä¸»é«”
					ctx.fillStyle = '#2a2a2a';
					ctx.fillRect(80, 130, 200, 40);

					// æ§ç®¡
					ctx.fillStyle = '#1a1a1a';
					ctx.fillRect(20, 140, 80, 20);

					// æ¡æŠŠ
					ctx.fillStyle = '#3a2a1a';
					ctx.fillRect(220, 160, 30, 60);

					// ç„æº–å™¨
					ctx.fillStyle = '#444';
					ctx.fillRect(150, 120, 30, 15);

					// å½ˆåŒ£
					ctx.fillStyle = '#333';
					ctx.fillRect(160, 170, 40, 35);

					// é‡‘å±¬å…‰æ¾¤
					ctx.fillStyle = 'rgba(255,255,255,0.1)';
					ctx.fillRect(80, 130, 200, 5);

					// èºçµ²
					ctx.fillStyle = '#555';
					ctx.beginPath();
					ctx.arc(100, 150, 4, 0, Math.PI * 2);
					ctx.fill();
					ctx.beginPath();
					ctx.arc(250, 150, 4, 0, Math.PI * 2);
					ctx.fill();
				} else {
					// ç«ç®­ç ² RPG
					// ç™¼å°„ç®¡
					ctx.fillStyle = '#3a5a3a';
					ctx.fillRect(30, 115, 220, 50);

					// ç™¼å°„ç®¡å‰ç«¯ (å–‡å­å£)
					ctx.fillStyle = '#2a4a2a';
					ctx.beginPath();
					ctx.moveTo(30, 105);
					ctx.lineTo(0, 90);
					ctx.lineTo(0, 190);
					ctx.lineTo(30, 175);
					ctx.closePath();
					ctx.fill();

					// ç™¼å°„ç®¡ç´‹è·¯
					ctx.strokeStyle = '#1a3a1a';
					ctx.lineWidth = 2;
					for (let i = 0; i < 5; i++) {
						ctx.beginPath();
						ctx.moveTo(50 + i * 40, 115);
						ctx.lineTo(50 + i * 40, 165);
						ctx.stroke();
					}

					// ç„æº–å™¨
					ctx.fillStyle = '#444';
					ctx.fillRect(120, 100, 40, 15);
					ctx.fillStyle = '#f00';
					ctx.fillRect(138, 103, 4, 9);

					// æ¡æŠŠ
					ctx.fillStyle = '#3a2a1a';
					ctx.fillRect(200, 160, 35, 60);

					// æ‰³æ©Ÿè­·å¼“
					ctx.strokeStyle = '#2a2a2a';
					ctx.lineWidth = 4;
					ctx.beginPath();
					ctx.arc(210, 175, 15, 0, Math.PI);
					ctx.stroke();

					// è‚©æ‰˜
					ctx.fillStyle = '#4a3a2a';
					ctx.beginPath();
					ctx.moveTo(250, 120);
					ctx.lineTo(320, 130);
					ctx.lineTo(320, 160);
					ctx.lineTo(250, 160);
					ctx.closePath();
					ctx.fill();

					// ç«ç®­å½ˆé ­ (å¦‚æœæœ‰å½ˆè—¥)
					if (player.rocketAmmo > 0) {
						ctx.fillStyle = '#666';
						ctx.fillRect(10, 125, 25, 30);
						ctx.fillStyle = '#c00';
						ctx.beginPath();
						ctx.moveTo(10, 125);
						ctx.lineTo(-5, 140);
						ctx.lineTo(10, 155);
						ctx.closePath();
						ctx.fill();
					}

					// é‡‘å±¬å…‰æ¾¤
					ctx.fillStyle = 'rgba(255,255,255,0.1)';
					ctx.fillRect(30, 115, 220, 8);
				}

				ctx.restore();
			}

			function drawMinimap() {
				const canvas = document.getElementById('minimap');
				const ctx = canvas.getContext('2d');
				canvas.width = 150;
				canvas.height = 150;

				// èƒŒæ™¯
				ctx.fillStyle = 'rgba(0, 20, 0, 0.8)';
				ctx.fillRect(0, 0, 150, 150);

				// ç¶²æ ¼
				ctx.strokeStyle = 'rgba(0, 100, 0, 0.3)';
				ctx.lineWidth = 1;
				for (let i = 0; i <= 150; i += 15) {
					ctx.beginPath();
					ctx.moveTo(i, 0);
					ctx.lineTo(i, 150);
					ctx.stroke();
					ctx.beginPath();
					ctx.moveTo(0, i);
					ctx.lineTo(150, i);
					ctx.stroke();
				}

				const scale = 1.5;
				const centerX = 75;
				const centerY = 75;

				// ç‰†å£
				ctx.fillStyle = '#444';
				walls.forEach(w => {
					const wx = centerX + (w.mesh.position.x - camera.position.x) * scale;
					const wy = centerY + (w.mesh.position.z - camera.position.z) * scale;
					const size = Math.max(3, w.mesh.geometry.parameters.width * scale * 0.3);
					if (wx > -10 && wx < 160 && wy > -10 && wy < 160) {
						ctx.fillRect(wx - size / 2, wy - size / 2, size, size);
					}
				});

				// æ•µäºº (æ ¹æ“šé¡å‹é¡¯ç¤ºä¸åŒé¡è‰²)
				enemies.forEach(e => {
					if (!e.userData || e.userData.health <= 0) return;
					const ex = centerX + (e.position.x - camera.position.x) * scale;
					const ey = centerY + (e.position.z - camera.position.z) * scale;
					if (ex > 0 && ex < 150 && ey > 0 && ey < 150) {
						// æ ¹æ“šæ•µäººé¡å‹è¨­å®šé¡è‰²
						if (e.userData.type === 'boss') {
							ctx.fillStyle = '#f0f'; // ç´«è‰² Boss
						} else if (e.userData.type === 'elite') {
							ctx.fillStyle = '#f80'; // æ©™è‰²ç²¾è‹±
						} else {
							ctx.fillStyle = '#f00'; // ç´…è‰²æ™®é€šæ•µäºº
						}
						ctx.beginPath();
						ctx.arc(ex, ey, 4, 0, Math.PI * 2);
						ctx.fill();
					}
				});

				// æ¨™é¶ (å½©è‰²é»)
				targets.forEach(t => {
					const tx = centerX + (t.position.x - camera.position.x) * scale;
					const ty = centerY + (t.position.z - camera.position.z) * scale;
					if (tx > 0 && tx < 150 && ty > 0 && ty < 150) {
						ctx.fillStyle = '#ff0';
						ctx.beginPath();
						ctx.arc(tx, ty, 5, 0, Math.PI * 2);
						ctx.fill();
						ctx.fillStyle = '#f00';
						ctx.beginPath();
						ctx.arc(tx, ty, 3, 0, Math.PI * 2);
						ctx.fill();
					}
				});

				// ç©å®¶ (ç¶ è‰²ä¸‰è§’å½¢ï¼ŒæŒ‡å‘è¦–è§’æ–¹å‘)
				ctx.fillStyle = '#0f0';
				ctx.save();
				ctx.translate(centerX, centerY);
				ctx.rotate(-camera.rotation.y);
				ctx.beginPath();
				ctx.moveTo(0, -8);
				ctx.lineTo(-5, 6);
				ctx.lineTo(5, 6);
				ctx.closePath();
				ctx.fill();
				ctx.restore();

				// é‚Šæ¡†
				ctx.strokeStyle = '#0f0';
				ctx.lineWidth = 2;
				ctx.strokeRect(0, 0, 150, 150);
			}

			function showKillStreak() {
				const streakNames = {
					2: 'DOUBLE KILL!',
					3: 'TRIPLE KILL!',
					4: 'MEGA KILL!',
					5: 'ULTRA KILL!',
					6: 'MONSTER KILL!',
					7: 'GODLIKE!',
				};

				if (killStreak >= 2) {
					const name = streakNames[Math.min(killStreak, 7)];
					const streak = document.getElementById('killStreak');
					streak.textContent = name;
					streak.style.opacity = '1';
					streak.style.transform = 'translateX(-50%) scale(1.2)';
					setTimeout(() => {
						streak.style.opacity = '0';
						streak.style.transform = 'translateX(-50%) scale(1)';
					}, 1500);
				}
			}

			function createFloatingText(text, x, y) {
				const div = document.createElement('div');
				div.className = 'combo-text';
				div.textContent = text;
				div.style.left = x + 'px';
				div.style.top = y + 'px';
				document.body.appendChild(div);
				setTimeout(() => div.remove(), 1000);
			}

			function shoot() {
				// æ ¹æ“šæ­¦å™¨é¡å‹è™•ç†
				if (player.currentWeapon === 1) {
					// SMG è¡é‹’æ§ - ç‰©ç†å­å½ˆ
					if (player.isReloading) return;
					if (player.ammo <= 0) {
						playSound('empty');
						reload();
						return;
					}

					const now = Date.now();
					if (now - lastShootTime < 120) return;
					lastShootTime = now;

					player.ammo--;
					updateHUD();
					playSound('shoot');

					// å¾Œåº§åŠ›
					weaponRecoil = 1;

					// æ§å£ç«ç„°
					const flash = document.getElementById('muzzleFlash');
					flash.style.opacity = '1';
					setTimeout(() => (flash.style.opacity = '0'), 50);

					// ç™¼å°„ç‰©ç†å­å½ˆ
					const direction = new THREE.Vector3();
					camera.getWorldDirection(direction);
					const start = camera.position.clone().add(direction.clone().multiplyScalar(0.5));
					createBullet(start, direction);
				} else if (player.currentWeapon === 2) {
					// ç«ç®­ç ²
					if (player.isReloading) return;
					if (player.rocketAmmo <= 0) {
						playSound('empty');
						reload();
						return;
					}

					const now = Date.now();
					if (now - lastShootTime < 800) return;
					lastShootTime = now;

					player.rocketAmmo--;
					updateHUD();

					playSound('shoot');
					playSound('reload');

					weaponRecoil = 2;
					screenShake = 5;

					const direction = new THREE.Vector3();
					camera.getWorldDirection(direction);
					const start = camera.position.clone().add(direction.clone().multiplyScalar(1));
					createRocket(start, direction, 0.001); // ç«ç®­ï¼šæ¥µè¼•é‡åŠ›

					showMessage('ROCKET FIRED!');
				} else if (player.currentWeapon === 3) {
					// æ‰‹æ¦´å½ˆ
					if (player.isReloading) return;
					if (player.grenadeAmmo <= 0) {
						playSound('empty');
						reload(); // è‡ªå‹•reload
						return;
					}

					const now = Date.now();
					if (now - lastShootTime < 500) return;
					lastShootTime = now;

					player.grenadeAmmo--;
					updateHUD();

					playSound('reload');

					weaponRecoil = 1;
					screenShake = 2;

					const direction = new THREE.Vector3();
					camera.getWorldDirection(direction);
					const start = camera.position.clone().add(direction.clone().multiplyScalar(1));
					createRocket(start, direction, 0.015); // æ‰‹æ¦´å½ˆï¼šé‡é‡åŠ›ï¼ˆæ‹‹ç‰©ç·šï¼‰

					showMessage('GRENADE THROWN!');
				}
			}

			function killEnemy(enemy) {
				const idx = enemies.indexOf(enemy);
				if (idx > -1) {
					enemies.splice(idx, 1);

					// æ­»äº¡å‹•ç•« - å€’ä¸‹
					const deathAnim = setInterval(() => {
						enemy.rotation.x += 0.1;
						enemy.position.y -= 0.05;
						if (enemy.rotation.x > Math.PI / 2) {
							clearInterval(deathAnim);
							scene.remove(enemy);
						}
					}, 16);

					player.kills++;

					// é€£æ®ºè¨ˆç®—
					const now = Date.now();
					if (now - lastKillTime < 2000) {
						killStreak++;
					} else {
						killStreak = 1;
					}
					lastKillTime = now;

					// é¡¯ç¤ºé€£æ®º
					showKillStreak();
					playSound('kill');

					// æµ®å‹•å¾—åˆ†æ–‡å­—
					const points = 100 * killStreak;
					createFloatingText(`+${points}`, window.innerWidth / 2, window.innerHeight / 2 - 50);

					// è¢å¹•éœ‡å‹•
					screenShake = 5;

					updateHUD();
	
					// é¡¯ç¤ºæ“Šæ®ºè¨Šæ¯
					showMessage('ENEMY KILLED!');

					if (enemies.length === 0) {
						difficulty += 0.5;
						killStreak = 0;
						showMessage('WAVE COMPLETE! NEXT WAVE INCOMING...');
						setTimeout(() => spawnEnemies(), 3000);
					}
				}
			}

			function showHitMarker(isHeadshot) {
				const marker = document.getElementById('hitMarker');
				marker.textContent = isHeadshot ? 'ğŸ’€' : 'âœ–';
				marker.style.color = isHeadshot ? '#ff0' : '#f00';
				marker.style.opacity = '1';
				setTimeout(() => (marker.style.opacity = '0'), 150);
			}

			function showMessage(text) {
				const msg = document.getElementById('message');
				msg.textContent = text;
				msg.style.opacity = '1';
				setTimeout(() => (msg.style.opacity = '0'), 2000);
			}

			function reload() {
				if (player.currentWeapon === 1) {
					// SMG reload
					if (player.isReloading || player.ammo === player.maxAmmo) return;
					player.isReloading = true;
					showMessage('RELOADING SMG...');
					playSound('reload');
					setTimeout(() => {
						player.ammo = player.maxAmmo;
						player.isReloading = false;
						updateHUD();
						playSound('reload');
					}, 1500);
				} else if (player.currentWeapon === 2) {
					// Rocket reload
					if (player.isReloading || player.rocketAmmo === player.maxRocketAmmo) return;
					player.isReloading = true;
					showMessage('RELOADING ROCKETS...');
					playSound('reload');
					setTimeout(() => {
						player.rocketAmmo = player.maxRocketAmmo;
						player.isReloading = false;
						updateHUD();
						playSound('reload');
					}, 2500);
				} else if (player.currentWeapon === 3) {
					// Grenade reload
					if (player.isReloading || player.grenadeAmmo === player.maxGrenadeAmmo) return;
					player.isReloading = true;
					showMessage('RELOADING GRENADES...');
					playSound('reload');
					setTimeout(() => {
						player.grenadeAmmo = player.maxGrenadeAmmo;
						player.isReloading = false;
						updateHUD();
						playSound('reload');
					}, 2000);
				}
			}

			// æ­¦å™¨åˆ‡æ›
			function switchWeapon(weaponNum) {
				if (weaponNum < 1 || weaponNum > 3) return;
				if (player.currentWeapon === weaponNum) return;
				player.currentWeapon = weaponNum;
				player.isReloading = false;

				// æ›´æ–° HUD é¡¯ç¤º
				document.getElementById('weaponPanel').style.opacity = '0.5';
				document.getElementById('rocketPanel').style.opacity = '0.5';
				document.getElementById('grenadePanel').style.opacity = '0.5';

				if (weaponNum === 1) {
					document.getElementById('weaponPanel').style.opacity = '1';
					document.getElementById('weaponName').textContent = '[ 1 ] SMG';
					showMessage('SWITCHED TO SMG');
				} else if (weaponNum === 2) {
					document.getElementById('rocketPanel').style.opacity = '1';
					document.getElementById('weaponName').textContent = '[ 2 ] ROCKET';
					showMessage('SWITCHED TO ROCKET LAUNCHER');
				} else if (weaponNum === 3) {
					document.getElementById('grenadePanel').style.opacity = '1';
					document.getElementById('weaponName').textContent = '[ 3 ] GRENADE';
					showMessage('SWITCHED TO GRENADE');
				}
				playSound('reload');
				drawWeapon();
			}

			// å‰µå»ºå­å½ˆè»Œè·¡
			function createBulletTrail(start, end) {
				const direction = new THREE.Vector3().subVectors(end, start);
				const length = direction.length();

				const geometry = new THREE.CylinderGeometry(0.008, 0.008, length, 3);
				const material = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.6 });
				const bullet = new THREE.Mesh(geometry, material);

				// å®šä½å­å½ˆ
				bullet.position.copy(start).add(end).multiplyScalar(0.5);
				bullet.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.normalize());

				bullet.userData = { life: 10 };
				scene.add(bullet);
				bullets.push(bullet);
			}

			// å­å½ˆæ“Šä¸­ç‰†å£çš„æ’æ“Šæ•ˆæœ
			function createBulletImpact(position, normal) {
				// Debugæ¨¡å¼ï¼šé¡¯ç¤ºå½ˆè‘—é»åº§æ¨™
				if (debugMode) {
					const p = position;
					const info = `HIT: X=${p.x.toFixed(1)} Y=${p.y.toFixed(1)} Z=${p.z.toFixed(1)}`;
					createFloatingText(info, window.innerWidth / 2, window.innerHeight / 2 + 50);
					console.log(info, 'Normal:', normal);
				}

				// å°ç«èŠ±
				for (let i = 0; i < 5; i++) {
					const sparkGeo = new THREE.SphereGeometry(0.03, 4, 4);
					const sparkMat = new THREE.MeshBasicMaterial({
						color: Math.random() > 0.5 ? 0xffff00 : 0xff8800,
					});
					const spark = new THREE.Mesh(sparkGeo, sparkMat);
					spark.position.copy(position);

					// ç«èŠ±æ²¿æ³•ç·šæ–¹å‘å™´å°„
					const vel = new THREE.Vector3(
						normal.x * 0.1 + (Math.random() - 0.5) * 0.1,
						normal.y * 0.1 + Math.random() * 0.05,
						normal.z * 0.1 + (Math.random() - 0.5) * 0.1
					);
					spark.userData = { velocity: vel, life: 15 };
					scene.add(spark);

					const animateSpark = () => {
						spark.position.add(spark.userData.velocity);
						spark.userData.velocity.y -= 0.005;
						spark.userData.life--;
						spark.material.opacity = spark.userData.life / 15;
						spark.material.transparent = true;
						if (spark.userData.life > 0) {
							requestAnimationFrame(animateSpark);
						} else {
							scene.remove(spark);
						}
					};
					animateSpark();
				}

				// å½ˆå­”æ¨™è¨˜
				const decalGeo = new THREE.CircleGeometry(0.1, 8);
				const decalMat = new THREE.MeshBasicMaterial({
					color: 0x222222,
					transparent: true,
					opacity: 0.8,
					side: THREE.DoubleSide,
				});
				const decal = new THREE.Mesh(decalGeo, decalMat);
				decal.position.copy(position).add(normal.clone().multiplyScalar(0.02));

				// æ ¹æ“šæ³•ç·šæ–¹å‘è¨­å®šå½ˆå­”è§’åº¦
				if (Math.abs(normal.y) > 0.9) {
					// åœ°æ¿æˆ–å¤©èŠ±æ¿ - æ°´å¹³æ”¾ç½®
					decal.rotation.x = -Math.PI / 2;
				} else {
					// ç‰†å£ - å°é½Šæ³•ç·š
					decal.lookAt(position.clone().add(normal));
				}

				decal.userData = { life: 300 }; // 5ç§’å¾Œæ·¡å‡º
				scene.add(decal);
				decals.push(decal);
			}

			// SMG ç‰©ç†å­å½ˆé™£åˆ—
			let smgBullets = [];

			// å‰µå»º SMG ç‰©ç†å­å½ˆ
			function createBullet(start, direction) {
				const bulletGeo = new THREE.SphereGeometry(0.05, 4, 4);
				const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
				const bullet = new THREE.Mesh(bulletGeo, bulletMat);

				bullet.position.copy(start);
				bullet.userData = {
					velocity: direction.clone().normalize().multiplyScalar(2.5), // å­å½ˆé€Ÿåº¦
					startPos: start.clone(),
					maxDistance: 100, // æœ€å¤§é£›è¡Œè·é›¢
					damage: 35,
				};

				scene.add(bullet);
				smgBullets.push(bullet);
			}

			// æ›´æ–° SMG å­å½ˆ
			function updateSmgBullets() {
				for (let i = smgBullets.length - 1; i >= 0; i--) {
					const bullet = smgBullets[i];

					// ç§»å‹•å­å½ˆï¼ˆç›´ç·šï¼Œç„¡é‡åŠ›ï¼‰- deltaTime æ¨™æº–åŒ–
					const moveVec = bullet.userData.velocity.clone().multiplyScalar(deltaTime * TARGET_FPS);
					const oldPos = bullet.position.clone();
					bullet.position.add(moveVec);

					// å‰µå»ºå­å½ˆæ‹–å°¾è»Œè·¡
					createBulletTrail(oldPos, bullet.position);

					// æª¢æŸ¥æ˜¯å¦è¶…éæœ€å¤§è·é›¢
					const dist = bullet.position.distanceTo(bullet.userData.startPos);
					if (dist > bullet.userData.maxDistance) {
						scene.remove(bullet);
						smgBullets.splice(i, 1);
						continue;
					}

					// ç¢°æ’æª¢æ¸¬ - ç”¨å°„ç·šå¾ä¸Šä¸€ä½ç½®åˆ°ç•¶å‰ä½ç½®
					const raycaster = new THREE.Raycaster();
					const rayDir = bullet.userData.velocity.clone().normalize();
					const rayOrigin = bullet.position.clone().sub(moveVec);
					raycaster.set(rayOrigin, rayDir);
					raycaster.far = moveVec.length() * 1.5;

					let hit = false;

					// æª¢æ¸¬ç‰†å£ï¼ˆæ’é™¤é†«ç™‚ç®±ï¼Œé†«ç™‚ç®±åœ¨å¾Œé¢å–®ç¨è™•ç†ï¼‰
					const wallMeshes = walls.filter(w => !w.isHealthBox).map(w => w.mesh);
					const wallHits = raycaster.intersectObjects(wallMeshes);
					if (wallHits.length > 0) {
						createBulletImpact(wallHits[0].point, wallHits[0].face.normal);
						playSound('hit');
						hit = true;
					}

					// æª¢æ¸¬åœ°æ¿
					if (!hit) {
						const floorMeshes = floors.map(f => f.mesh);
						const floorHits = raycaster.intersectObjects(floorMeshes);
						if (floorHits.length > 0) {
							createBulletImpact(floorHits[0].point, floorHits[0].face.normal);
							playSound('hit');
							hit = true;
						}
					}

					// æª¢æ¸¬æ•µäºº
					if (!hit) {
						const enemyMeshes = enemies.flatMap(e => e.children);
						const enemyHits = raycaster.intersectObjects(enemyMeshes);
						if (enemyHits.length > 0) {
							const hitPart = enemyHits[0].object;
							const enemy = hitPart.parent;
							if (enemy.userData && enemy.userData.isEnemy) {
								const multiplier = hitPart.userData.damageMultiplier || 1;
								const finalDamage = Math.floor(bullet.userData.damage * multiplier);
								const isHeadshot = hitPart.userData.isHead;

								showHitMarker(isHeadshot);
								if (isHeadshot) {
									playSound('kill');
									createFloatingText('HEADSHOT!', window.innerWidth / 2, window.innerHeight / 2 - 30);
								} else {
									playSound('hit');
								}
								damageEnemy(enemy, finalDamage);
							}
							hit = true;
						}
					}

					// æª¢æ¸¬æ¨™é¶
					if (!hit) {
						const targetMeshes = targets.flatMap(t => t.children);
						const targetHits = raycaster.intersectObjects(targetMeshes);
						if (targetHits.length > 0) {
							const target = targetHits[0].object.parent;
							const hitFace = targetHits[0].object;
							if (target.userData && target.userData.isTarget) {
								target.userData.health -= bullet.userData.damage;
								showHitMarker(false);
								playSound('hit');

								target.children.forEach(c => {
									if (c.material && c.material.color) {
										const origColor = c.material.color.getHex();
										c.material.color.setHex(0xffffff);
										setTimeout(() => c.material.color.setHex(origColor), 80);
									}
								});

								if (target.userData.health <= 0) {
									const score =
										hitFace.userData && hitFace.userData.score ? hitFace.userData.score : 100;
									roundScore += score;
									totalScore += score;
									createFloatingText(`+${score}`, window.innerWidth / 2, window.innerHeight / 2 - 50);
									updateHUD();
									explodeTarget(target);
								}
							}
							hit = true;
						}
					}

					// æª¢æ¸¬é†«ç™‚ç®±
					if (!hit) {
						const healthBoxHits = raycaster.intersectObjects(healthBoxes);
						if (healthBoxHits.length > 0) {
							const cube = healthBoxHits[0].object;
							if (cube.userData && cube.userData.isHealthCube && cube.userData.health > 0) {
								damageHealthCube(cube, bullet.userData.damage);
								playSound('hit');
							}
							hit = true;
						}
					}

					// å‘½ä¸­å¾Œç§»é™¤å­å½ˆ
					if (hit) {
						scene.remove(bullet);
						smgBullets.splice(i, 1);
					}
				}
			}

			// ç«ç®­ç…™è·¡é™£åˆ—
			let rocketTrails = [];

			// å‰µå»ºç«ç®­ç…™è·¡ç²’å­
			function createRocketTrail(position) {
				const trailGeo = new THREE.SphereGeometry(0.15, 4, 4);
				const trailMat = new THREE.MeshBasicMaterial({
					color: 0xff8800,
					transparent: true,
					opacity: 0.8,
				});
				const trail = new THREE.Mesh(trailGeo, trailMat);
				trail.position.copy(position);
				trail.userData = { life: 30 }; // 0.5 ç§’
				scene.add(trail);
				rocketTrails.push(trail);
			}

			// æ›´æ–°ç«ç®­ç…™è·¡
			function updateRocketTrails() {
				for (let i = rocketTrails.length - 1; i >= 0; i--) {
					const trail = rocketTrails[i];
					trail.userData.life--;
					// é€æ¼¸è®Šå°ã€è®Šæ·¡ã€è®Šç°
					const lifeRatio = trail.userData.life / 30;
					trail.scale.setScalar(0.5 + lifeRatio * 0.5);
					trail.material.opacity = lifeRatio * 0.8;
					// é¡è‰²å¾æ©˜ç´…æ¼¸è®Šåˆ°ç°è‰²
					const r = Math.floor(255 * lifeRatio + 100 * (1 - lifeRatio));
					const g = Math.floor(136 * lifeRatio + 100 * (1 - lifeRatio));
					const b = Math.floor(0 * lifeRatio + 100 * (1 - lifeRatio));
					trail.material.color.setRGB(r / 255, g / 255, b / 255);

					if (trail.userData.life <= 0) {
						scene.remove(trail);
						rocketTrails.splice(i, 1);
					}
				}
			}

			// å‰µå»ºç«ç®­/æ‰‹æ¦´å½ˆï¼ˆgravity åƒæ•¸æ±ºå®šé‡åŠ›å¤§å°ï¼‰
			function createRocket(start, direction, gravity = 0.003) {
				const rocket = new THREE.Group();

				// æ ¹æ“šé‡åŠ›å¤§å°æ±ºå®šå¤–è§€ï¼ˆæ‰‹æ¦´å½ˆ vs ç«ç®­ï¼‰
				const isGrenade = gravity > 0.01;

				if (isGrenade) {
					// æ‰‹æ¦´å½ˆå¤–è§€ - åœ“çƒ
					const bodyGeo = new THREE.SphereGeometry(0.15, 8, 8);
					const bodyMat = new THREE.MeshLambertMaterial({ color: 0x2d5a27 }); // è»ç¶ è‰²
					const body = new THREE.Mesh(bodyGeo, bodyMat);
					rocket.add(body);

					// æ‰‹æ¦´å½ˆæ‹‰ç’°
					const ringGeo = new THREE.TorusGeometry(0.05, 0.015, 8, 12);
					const ringMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
					const ring = new THREE.Mesh(ringGeo, ringMat);
					ring.position.y = 0.18;
					rocket.add(ring);
				} else {
					// ç«ç®­æœ¬é«” - åŠ å¤§å°ºå¯¸
					const bodyGeo = new THREE.CylinderGeometry(0.15, 0.2, 0.8, 8);
					const bodyMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
					const body = new THREE.Mesh(bodyGeo, bodyMat);
					body.rotation.x = Math.PI / 2;
					rocket.add(body);

					// ç«ç®­é ­ - åŠ å¤§
					const headGeo = new THREE.ConeGeometry(0.15, 0.25, 8);
					const headMat = new THREE.MeshLambertMaterial({ color: 0xff0000 });
					const head = new THREE.Mesh(headGeo, headMat);
					head.rotation.x = Math.PI / 2;
					head.position.z = -0.5;
					rocket.add(head);

					// å°¾ç„° - åŠ å¤§
					const flameGeo = new THREE.ConeGeometry(0.12, 0.4, 8);
					const flameMat = new THREE.MeshBasicMaterial({ color: 0xff6600 });
					const flame = new THREE.Mesh(flameGeo, flameMat);
					flame.rotation.x = -Math.PI / 2;
					flame.position.z = 0.55;
					rocket.add(flame);
				}

				rocket.position.copy(start);
				rocket.userData = {
					velocity: direction.clone().multiplyScalar(isGrenade ? 0.5 : 0.8), // æ‰‹æ¦´å½ˆé€Ÿåº¦è¼ƒæ…¢
					life: 300,
					lastY: start.y,
					startPos: start.clone(),
					gravity: gravity, // å„²å­˜é‡åŠ›å€¼
					isGrenade: isGrenade,
				};

				// è®“ç«ç®­æœå‘é£›è¡Œæ–¹å‘
				rocket.lookAt(start.clone().add(direction));

				scene.add(rocket);
				rockets.push(rocket);
			}

			// æ›´æ–°å­å½ˆå’Œç«ç®­
			function updateProjectiles() {
				// æ›´æ–°å­å½ˆè»Œè·¡
				for (let i = bullets.length - 1; i >= 0; i--) {
					const bullet = bullets[i];
					bullet.userData.life--;
					bullet.material.opacity = bullet.userData.life / 10;
					if (bullet.userData.life <= 0) {
						scene.remove(bullet);
						bullets.splice(i, 1);
					}
				}

				// æ›´æ–°ç«ç®­/æ‰‹æ¦´å½ˆ
				for (let i = rockets.length - 1; i >= 0; i--) {
					const rocket = rockets[i];

					// é‡åŠ›å½±éŸ¿ï¼ˆæ‹‹ç‰©ç·šï¼‰- deltaTime æ¨™æº–åŒ–
					rocket.userData.velocity.y -= rocket.userData.gravity * deltaTime * TARGET_FPS;

					// ç§»å‹• - deltaTime æ¨™æº–åŒ–
					const moveVec = rocket.userData.velocity.clone().multiplyScalar(deltaTime * TARGET_FPS);
					rocket.position.add(moveVec);
					rocket.userData.life--;

					// ç«ç®­/æ‰‹æ¦´å½ˆæœå‘é£›è¡Œæ–¹å‘ï¼ˆè·Ÿè‘—é€Ÿåº¦è½‰å‘ï¼‰
					const lookTarget = rocket.position.clone().add(rocket.userData.velocity);
					rocket.lookAt(lookTarget);

					// æ‰‹æ¦´å½ˆæ—‹è½‰æ•ˆæœ - deltaTime æ¨™æº–åŒ–
					if (rocket.userData.isGrenade) {
						rocket.rotation.x += 12 * deltaTime;  // 0.2 Ã— 60
						rocket.rotation.z += 6 * deltaTime;   // 0.1 Ã— 60
					}

					// å°¾ç„°é–ƒçˆ + ç…™è·¡ï¼ˆåªæœ‰ç«ç®­æœ‰ï¼‰
					if (!rocket.userData.isGrenade) {
						const flame = rocket.children[2];
						if (flame) {
							flame.scale.setScalar(0.8 + Math.random() * 0.4);
						}
						// æ¯ 2 å¹€ç”¢ç”Ÿä¸€å€‹ç…™è·¡ç²’å­
						if (rocket.userData.life % 2 === 0) {
							createRocketTrail(rocket.position.clone());
						}
					}

					// æª¢æ¸¬ç¢°æ’
					let hit = false;
					let hitPoint = rocket.position.clone();

					// æª¢æ¸¬æ¨™é¶ç¢°æ’
					targets.forEach(target => {
						if (target.userData.health > 0) {
							const dist = rocket.position.distanceTo(target.position);
							if (dist < 2) {
								hit = true;
								hitPoint = rocket.position.clone();
							}
						}
					});

					// æª¢æ¸¬ç‰†å£ç¢°æ’
					let hitFloor = false; // æ¨™è¨˜æ˜¯å¦æ‰“åˆ°åœ°æ¿
					walls.forEach(w => {
						if (w.box.containsPoint(rocket.position)) {
							hit = true;
							hitPoint = rocket.position.clone();
						}
					});

					// æª¢æ¸¬åœ°æ¿ç¢°æ’ - ç«ç®­ç©¿éä»»ä½•åœ°æ¿è¡¨é¢éƒ½ç®—æ’æ“Š
					// æª¢æŸ¥æ¯å€‹åœ°æ¿çš„å¯¦éš› Y é«˜åº¦ï¼Œä¸åªæ˜¯ Y=0
					const lastY = rocket.userData.lastY;
					const currY = rocket.position.y;
					floors.forEach((f, idx) => {
						if (f.box && !hit) {
							const floorTopY = f.box.max.y; // åœ°æ¿é ‚é¢é«˜åº¦
							const rocketXZ = new THREE.Vector2(rocket.position.x, rocket.position.z);
							const floorMinXZ = new THREE.Vector2(f.box.min.x, f.box.min.z);
							const floorMaxXZ = new THREE.Vector2(f.box.max.x, f.box.max.z);

							// æª¢æŸ¥ XZ æ˜¯å¦åœ¨åœ°æ¿ç¯„åœå…§
							if (
								rocketXZ.x >= floorMinXZ.x &&
								rocketXZ.x <= floorMaxXZ.x &&
								rocketXZ.y >= floorMinXZ.y &&
								rocketXZ.y <= floorMaxXZ.y
							) {
								// æª¢æŸ¥æ˜¯å¦ç©¿éé€™å€‹åœ°æ¿çš„é ‚é¢ï¼ˆå¾ä¸Šæ–¹ç©¿å…¥ï¼‰
								if (lastY > floorTopY && currY <= floorTopY) {
									hit = true;
									hitFloor = true; // æ¨™è¨˜æ‰“åˆ°åœ°æ¿
									hitPoint = rocket.position.clone();
									hitPoint.y = floorTopY; // çˆ†ç‚¸é»åœ¨è©²åœ°æ¿è¡¨é¢
								}
							}
						}
					});
					// æ›´æ–° lastY ä¾›ä¸‹ä¸€å¹€ä½¿ç”¨
					rocket.userData.lastY = currY;

					// æª¢æ¸¬æ•µäººç¢°æ’ï¼ˆç›´æ¥å‘½ä¸­ï¼‰
					enemies.forEach(enemy => {
						if (enemy.userData.health > 0) {
							const dist = rocket.position.distanceTo(enemy.position);
							const hitRadius = (enemy.userData.scale || 1) * 1.5; // æ ¹æ“šæ•µäººå¤§å°èª¿æ•´ç¢°æ’åŠå¾‘
							if (dist < hitRadius) {
								hit = true;
								hitPoint = rocket.position.clone();
							}
						}
					});

					// è¶…æ™‚çˆ†ç‚¸ï¼ˆå®‰å…¨ç¶²ï¼šé˜²æ­¢é£›å‡ºåœ°åœ–æ°¸é ä¸çˆ†ï¼‰
					// æœ‰é‡åŠ›ç‰©ç†å¾Œï¼Œå¤§å¤šæ•¸æƒ…æ³æœƒè‡ªç„¶è½åœ°ï¼Œé€™åªæ˜¯å‚™ç”¨
					if (rocket.userData.life <= 0) {
						hit = true;
					}

					if (hit) {
						// çˆ†ç‚¸ï¼æ‰‹æ¦´å½ˆçˆ†ç‚¸æ›´å¤§
						createExplosion(hitPoint, rocket.userData.isGrenade ? 1.5 : 1.0);

						// ç«ç®­è·³ï¼åªæœ‰æ‰“åˆ°åœ°æ¿ä¸”ç©å®¶å¾ˆè¿‘æ™‚æ‰è§¸ç™¼è‡ªå‚·
						const playerPos = camera.position.clone();
						const distToPlayer = hitPoint.distanceTo(playerPos);
						const rocketJumpRadius = 4; // ç«ç®­è·³æœ‰æ•ˆç¯„åœ

						// åªæœ‰æ‰“åˆ°åœ°æ¿æ‰æœƒè‡ªå‚·ï¼ˆæ‰“æ•µäººã€æ‰“ç‰†å£ã€ç©ºä¸­çˆ†ç‚¸éƒ½ä¸æœƒè‡ªå‚·ï¼‰
						if (hitFloor && distToPlayer < rocketJumpRadius) {
							// è¨ˆç®—å‚·å®³æ¯”ä¾‹ (è·é›¢è¶Šè¿‘å‚·å®³è¶Šé«˜)
							const damageRatio = 1 - distToPlayer / rocketJumpRadius;
							const selfDamage = Math.floor(15 * damageRatio); // æœ€å¤§è‡ªå‚·15é»

							// é€ æˆè‡ªå‚·
							if (selfDamage > 0) {
								player.health -= selfDamage;
								showDamage();
								updateHUD();
								createFloatingText(
									`-${selfDamage}`,
									window.innerWidth / 2,
									window.innerHeight / 2 + 30
								);
							}

							// ç«ç®­è·³ï¼å½ˆé£›ç©å®¶
							const jumpBoost = player.jumpForce * damageRatio * 1.2;
							if (jumpBoost > 0.05) {
								player.velocity.y = Math.max(player.velocity.y, jumpBoost);
								player.onGround = false;
								showMessage('ROCKET JUMP!');
							}

							if (player.health <= 0) endGame();
						}

						// æ‰‹æ¦´å½ˆçˆ†ç‚¸ç¯„åœæ›´å¤§ï¼Œä½†å‚·å®³è¼ƒä½
						const isGrenade = rocket.userData.isGrenade;
						const blastRadius = isGrenade ? 12 : 8; // æ‰‹æ¦´å½ˆ 12ï¼Œç«ç®­ 8
						const maxDamage = isGrenade ? 100 : 150; // æ‰‹æ¦´å½ˆ 100ï¼Œç«ç®­ 150
						const emoji = isGrenade ? 'ğŸ’£' : 'ğŸš€';

						// ç¯„åœå‚·å®³ - æ¨™é¶
						targets.forEach(target => {
							if (target.userData.health > 0) {
								const dist = hitPoint.distanceTo(target.position);
								if (dist < blastRadius) {
									const damage = Math.floor(maxDamage * (1 - dist / blastRadius));
									target.userData.health -= damage;
									if (target.userData.health <= 0) {
										// ç«ç®­/æ‰‹æ¦´å½ˆæ“Šæ®ºçµ¦é¡å¤–åˆ†æ•¸
										const faceScores = target.userData.faceScores || [100, 100, 100, 100];
										const score = Math.max(...faceScores);
										roundScore += score;
										totalScore += score;
										createFloatingText(
											`+${score} ${emoji}`,
											window.innerWidth / 2,
											window.innerHeight / 2 - 80
										);
										explodeTarget(target);
									}
								}
							}
						});

						enemies.forEach(enemy => {
							if (enemy.userData.health > 0) {
								const dist = hitPoint.distanceTo(enemy.position);
								if (dist < blastRadius) {
									// è·é›¢è¶Šè¿‘å‚·å®³è¶Šé«˜
									const damage = Math.floor(maxDamage * (1 - dist / blastRadius));
									damageEnemy(enemy, damage);

									// é¡¯ç¤ºå‚·å®³æ•¸å­—
									const screenPos = enemy.position.clone().project(camera);
									const x = ((screenPos.x + 1) / 2) * window.innerWidth;
									const y = ((-screenPos.y + 1) / 2) * window.innerHeight;
									createFloatingText(`-${damage} ${emoji}`, x, y);
								}
							}
						});

						// ç¯„åœå‚·å®³ - é†«ç™‚ç®±å°æ–¹å¡Šï¼ˆç”¨å‰¯æœ¬éæ­·ï¼Œå› ç‚ºå¯èƒ½æœƒè¢«ç§»é™¤ï¼‰
						[...healthBoxes].forEach(cube => {
							if (cube.userData && cube.userData.isHealthCube && cube.userData.health > 0) {
								const dist = hitPoint.distanceTo(cube.position);
								if (dist < blastRadius) {
									// è·é›¢è¶Šè¿‘å‚·å®³è¶Šé«˜
									const damage = Math.floor(maxDamage * (1 - dist / blastRadius));
									damageHealthCube(cube, damage);
								}
							}
						});

						scene.remove(rocket);
						rockets.splice(i, 1);
						playSound('kill');
					}
				}
			}

			// çˆ†ç‚¸æ•ˆæœï¼ˆexplosionScale æ§åˆ¶çˆ†ç‚¸å¤§å°ï¼‰
			function createExplosion(position, explosionScale = 1.0) {
				// æ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆ
				playSound('explosion');

				// çˆ†ç‚¸å…‰çƒ
				const explosionGeo = new THREE.SphereGeometry(0.5 * explosionScale, 16, 16);
				const explosionMat = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 1 });
				const explosion = new THREE.Mesh(explosionGeo, explosionMat);
				explosion.position.copy(position);
				scene.add(explosion);

				// çˆ†ç‚¸å‹•ç•«
				let scale = 1;
				const scaleSpeed = 0.5 * explosionScale;
				const animateExplosion = () => {
					scale += scaleSpeed;
					explosion.scale.setScalar(scale);
					explosion.material.opacity -= 0.08;
					if (explosion.material.opacity > 0) {
						requestAnimationFrame(animateExplosion);
					} else {
						scene.remove(explosion);
					}
				};
				animateExplosion();

				// è¢å¹•éœ‡å‹•ï¼ˆæ‰‹æ¦´å½ˆéœ‡å‹•æ›´å¤§ï¼‰
				screenShake = 10 * explosionScale;

				// çˆ†ç‚¸ç¢ç‰‡ï¼ˆæ‰‹æ¦´å½ˆç¢ç‰‡æ›´å¤šï¼‰
				const sparkCount = Math.floor(12 * explosionScale);
				for (let i = 0; i < sparkCount; i++) {
					const sparkGeo = new THREE.SphereGeometry(0.1 * explosionScale, 4, 4);
					const sparkMat = new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0xff4400 : 0xffff00 });
					const spark = new THREE.Mesh(sparkGeo, sparkMat);
					spark.position.copy(position);
					spark.userData = {
						velocity: new THREE.Vector3(
							(Math.random() - 0.5) * 0.4 * explosionScale,
							Math.random() * 0.3 * explosionScale,
							(Math.random() - 0.5) * 0.4 * explosionScale
						),
						life: 30,
					};
					scene.add(spark);

					const animateSpark = () => {
						spark.position.add(spark.userData.velocity);
						spark.userData.velocity.y -= 0.015;
						spark.userData.life--;
						if (spark.userData.life > 0) {
							requestAnimationFrame(animateSpark);
						} else {
							scene.remove(spark);
						}
					};
					animateSpark();
				}
			}

			function updatePlayer() {
				const forward = new THREE.Vector3();
				camera.getWorldDirection(forward);
				forward.y = 0;
				forward.normalize();

				const right = new THREE.Vector3();
				right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

				const move = new THREE.Vector3();
				if (keys['KeyW']) move.add(forward);
				if (keys['KeyS']) move.sub(forward);
				if (keys['KeyD']) move.add(right);
				if (keys['KeyA']) move.sub(right);

				const currentSpeed = player.isSprinting ? player.sprintSpeed : player.speed;

				if (move.length() > 0) {
					move.normalize().multiplyScalar(currentSpeed * deltaTime * TARGET_FPS);
					// èµ°è·¯æ™ƒå‹•
					player.bobPhase += currentSpeed * 30 * deltaTime;
				}

				// è·³èº
				if (keys['Space'] && player.onGround) {
					player.velocity.y = player.jumpForce;
					player.onGround = false;
				}

				// é‡åŠ› (0.015 Ã— 60 = 0.9 æ¯ç§’)
				player.velocity.y -= 0.9 * deltaTime;

				const newX = camera.position.x + move.x;
				const newZ = camera.position.z + move.z;
				const newY = camera.position.y + player.velocity.y * deltaTime * TARGET_FPS;

				// ç¢°æ’æª¢æ¸¬
				let canMoveX = true,
					canMoveZ = true;
				const playerRadius = 0.4;
				const feetY = newY - player.height; // è…³çš„ä½ç½®
				const headY = newY + 0.3; // é ­çš„ä½ç½®

				walls.forEach(w => {
					// æª¢æŸ¥ X æ–¹å‘ç§»å‹•
					const testX = new THREE.Box3(
						new THREE.Vector3(newX - playerRadius, feetY, camera.position.z - playerRadius),
						new THREE.Vector3(newX + playerRadius, headY, camera.position.z + playerRadius)
					);
					if (testX.intersectsBox(w.box)) canMoveX = false;

					// æª¢æŸ¥ Z æ–¹å‘ç§»å‹•
					const testZ = new THREE.Box3(
						new THREE.Vector3(camera.position.x - playerRadius, feetY, newZ - playerRadius),
						new THREE.Vector3(camera.position.x + playerRadius, headY, newZ + playerRadius)
					);
					if (testZ.intersectsBox(w.box)) canMoveZ = false;
				});

				if (canMoveX) camera.position.x = newX;
				if (canMoveZ) camera.position.z = newZ;

				// Y è»¸ç¢°æ’æª¢æ¸¬ï¼ˆç«™åœ¨ç®±å­ä¸Š or æ’åˆ°å¤©èŠ±æ¿ï¼‰
				let groundY = 0; // é è¨­åœ°é¢é«˜åº¦
				const playerBox = new THREE.Box3(
					new THREE.Vector3(camera.position.x - playerRadius, feetY, camera.position.z - playerRadius),
					new THREE.Vector3(camera.position.x + playerRadius, headY, camera.position.z + playerRadius)
				);

				// æª¢æ¸¬æ–œå¡é«˜åº¦ - å¹³æ»‘éæ¸¡
				ramps.forEach(ramp => {
					const px = camera.position.x;
					const pz = camera.position.z;
					// æª¢æŸ¥æ˜¯å¦åœ¨æ–œå¡Xç¯„åœå…§
					if (px >= ramp.x - ramp.width / 2 && px <= ramp.x + ramp.width / 2) {
						const rampHeight = ramp.getHeight(pz);
						if (rampHeight >= 0) {
							// åªæœ‰ç•¶ç©å®¶æ¥è¿‘æˆ–ä½æ–¼æ–œå¡é«˜åº¦æ™‚æ‰ç”Ÿæ•ˆ
							// é€™æ¨£å¯ä»¥è®“ç©å®¶è·³éæ–œå¡æˆ–å¾ä¸Šæ–¹è½ä¸‹
							if (feetY <= rampHeight + 0.5) {
								groundY = Math.max(groundY, rampHeight);
							}
						}
					}
				});

				walls.forEach(w => {
					if (playerBox.intersectsBox(w.box)) {
						// æª¢æŸ¥æ˜¯å¦ç«™åœ¨ç‰©é«”ä¸Šé¢
						const boxTop = w.box.max.y;
						const boxBottom = w.box.min.y;

						// å¦‚æœè…³åœ¨ç®±å­é ‚éƒ¨é™„è¿‘ï¼Œç«™ä¸Šå»
						if (feetY >= boxTop - 0.5 && feetY <= boxTop + 0.5) {
							groundY = Math.max(groundY, boxTop);
						}
						// å¦‚æœé ­æ’åˆ°ç®±å­åº•éƒ¨ï¼Œåœæ­¢ä¸Šå‡
						else if (player.velocity.y > 0 && headY > boxBottom && feetY < boxBottom) {
							player.velocity.y = 0;
						}
					}
				});

				// floors é™£åˆ—ä¹Ÿæª¢æ¸¬ç«™ç«‹ï¼ˆå±‹é ‚ã€åœ°æ¿ç­‰å¹³é¢ï¼‰
				floors.forEach(f => {
					if (playerBox.intersectsBox(f.box)) {
						const boxTop = f.box.max.y;
						// å¦‚æœè…³åœ¨å¹³å°é ‚éƒ¨é™„è¿‘ï¼Œç«™ä¸Šå»
						if (feetY >= boxTop - 0.5 && feetY <= boxTop + 0.5) {
							groundY = Math.max(groundY, boxTop);
						}
					}
				});

				// åœ°é¢æª¢æ¸¬
				if (newY - player.height <= groundY) {
					camera.position.y = groundY + player.height;
					player.velocity.y = 0;
					player.onGround = true;
				} else {
					camera.position.y = newY;
					// åªæœ‰çœŸçš„åœ¨ç©ºä¸­æ‰è¨­ç‚º false
					if (camera.position.y - player.height > groundY + 0.1) {
						player.onGround = false;
					}
				}

				// èµ°è·¯è¦–è§’æ™ƒå‹•
				if (player.onGround && move.length() > 0) {
					camera.position.y += Math.sin(player.bobPhase) * 0.05;
				}

				// é‚Šç•Œ (æ“´å¤§åœ°åœ–ï¼šå®¤å…§ -50~50ï¼Œæˆ¶å¤–å»¶ä¼¸åˆ° z=150)
				camera.position.x = Math.max(-48, Math.min(48, camera.position.x));
				camera.position.z = Math.max(-48, Math.min(148, camera.position.z));

				// å‚·å®³å€æª¢æ¸¬
				damageZones.forEach(zone => {
					let inZone = false;
					if (zone.type === 'lava' || zone.radius) {
						// åœ“å½¢å€åŸŸ (å²©æ¼¿)
						const dist = Math.sqrt((camera.position.x - zone.x) ** 2 + (camera.position.z - zone.z) ** 2);
						inZone = dist < (zone.radius || 5) && camera.position.y < 3;
					} else {
						// çŸ©å½¢å€åŸŸ
						const halfW = zone.w / 2;
						const halfD = zone.d / 2;
						inZone =
							camera.position.x > zone.x - halfW &&
							camera.position.x < zone.x + halfW &&
							camera.position.z > zone.z - halfD &&
							camera.position.z < zone.z + halfD &&
							camera.position.y < 3; // åªåœ¨åœ°é¢é™„è¿‘æ‰å—å‚·
					}

					if (inZone) {
						player.health -= zone.damage;
						showDamage();
						updateHUD();
						if (player.health <= 0) endGame();
					}
				});

				// å½ˆè·³å€æª¢æ¸¬
				jumpPads.forEach(pad => {
					const dist = Math.sqrt((camera.position.x - pad.x) ** 2 + (camera.position.z - pad.z) ** 2);
					if (dist < pad.radius && camera.position.y < player.height + 1 && player.onGround) {
						// è§¸ç™¼å½ˆè·³ï¼
						player.velocity.y = pad.jumpForce;
						player.onGround = false;
						playSound('jump'); // å½ˆè·³éŸ³æ•ˆ
						showMessage('BOOST!');

						// å½ˆè·³è¦–è¦ºæ•ˆæœ - å…‰æŸ±
						createJumpEffect(pad.x, pad.z);
					}
				});
			}

			// å½ˆè·³å…‰æŸ±æ•ˆæœ
			function createJumpEffect(x, z) {
				const beamGeo = new THREE.CylinderGeometry(0.5, 1.5, 15, 8, 1, true);
				const beamMat = new THREE.MeshBasicMaterial({
					color: 0x00ffff,
					transparent: true,
					opacity: 0.5,
					side: THREE.DoubleSide,
				});
				const beam = new THREE.Mesh(beamGeo, beamMat);
				beam.position.set(x, 7.5, z);
				scene.add(beam);

				// æ·¡å‡ºå‹•ç•«
				let opacity = 0.5;
				const animateBeam = () => {
					opacity -= 0.05;
					beam.material.opacity = opacity;
					beam.scale.x *= 0.95;
					beam.scale.z *= 0.95;
					if (opacity > 0) {
						requestAnimationFrame(animateBeam);
					} else {
						scene.remove(beam);
					}
				};
				animateBeam();
			}

			function showDamage() {
				const overlay = document.getElementById('damageOverlay');
				overlay.style.background = 'radial-gradient(ellipse at center, transparent 0%, rgba(255,0,0,0.6) 100%)';
				overlay.style.opacity = '1';
				playSound('hurt');
				setTimeout(() => (overlay.style.opacity = '0'), 200);
			}

			function updateHUD() {
				document.getElementById('health').textContent = Math.max(0, Math.floor(player.health));
				document.getElementById('ammo').textContent = player.ammo;
				document.getElementById('maxAmmo').textContent = player.maxAmmo;
				document.getElementById('rocketAmmo').textContent = player.rocketAmmo;
				document.getElementById('grenadeAmmo').textContent = player.grenadeAmmo;
				document.getElementById('waveNum').textContent = waveNumber;
				document.getElementById('waveKills').textContent = waveKills;
				document.getElementById('waveKillTarget').textContent = waveKillTarget;
				document.getElementById('totalScore').textContent = totalScore;
			}

			// æ›´æ–°å½ˆå­”æ·¡å‡º
			function updateDecals() {
				for (let i = decals.length - 1; i >= 0; i--) {
					const decal = decals[i];
					decal.userData.life--;
					if (decal.userData.life < 60) {
						decal.material.opacity = decal.userData.life / 60;
					}
					if (decal.userData.life <= 0) {
						scene.remove(decal);
						decals.splice(i, 1);
					}
				}
			}

			// å½ˆè·³å€è¦–è¦ºæ•ˆæœ
			function updateJumpPadEffects() {
				jumpPads.forEach(pad => {
					if (pad.pad) {
						pad.pad.userData.glowPhase += 0.1;
						const glow = 0.5 + Math.sin(pad.pad.userData.glowPhase) * 0.3;
						pad.pad.material.opacity = glow;
					}
					if (pad.light) {
						pad.light.intensity = 0.8 + Math.sin(pad.pad.userData.glowPhase) * 0.4;
					}
				});
			}

			function animate() {
				requestAnimationFrame(animate);

				// deltaTime è¨ˆç®— - éŠæˆ²æ™‚é–“æ¨™æº–åŒ–æ ¸å¿ƒ
				const now = performance.now();
				deltaTime = Math.min((now - lastFrameTime) / 1000, 0.1); // æœ€å¤§ 0.1 ç§’ï¼Œé˜²æ­¢åˆ‡é å›ä¾†å¤§è·³èº
				lastFrameTime = now;

				// FPS è¨ˆç®—
				fpsFrames++;
				if (now - fpsLastTime >= 1000) {
					fpsDisplay = fpsFrames;
					fpsFrames = 0;
					fpsLastTime = now;
					const fpsEl = document.getElementById('fpsCounter');
					fpsEl.textContent = `FPS: ${fpsDisplay}`;
					// æ ¹æ“š FPS è®Šè‰²
					if (fpsDisplay >= 55) {
						fpsEl.style.color = '#0f0'; // ç¶ è‰² - æµæš¢
					} else if (fpsDisplay >= 30) {
						fpsEl.style.color = '#ff0'; // é»ƒè‰² - é‚„è¡Œ
					} else {
						fpsEl.style.color = '#f00'; // ç´…è‰² - å¡é “
					}
				}

				if (gameStarted && !gameOver) {
					updatePlayer();
					updateEnemies(); // æ›´æ–°æ•µäººAI
					updateEnemyProjectiles(); // æ›´æ–°æ•µäººæŠ•å°„ç‰©ï¼ˆçŸ³é ­ã€ç«çƒï¼‰
					updateTargets(); // æ›´æ–°æ¨™é¶å‹•ç•«
					updateProjectiles(); // æ›´æ–°ç«ç®­å’Œæ‰‹æ¦´å½ˆ
					updateSmgBullets(); // æ›´æ–° SMG ç‰©ç†å­å½ˆ
					updateRocketTrails(); // æ›´æ–°ç«ç®­ç…™è·¡
					updateDecals(); // æ›´æ–°å½ˆå­”æ·¡å‡º
					updateJumpPadEffects(); // å½ˆè·³å€è¦–è¦ºæ•ˆæœ
					updateHealthPickups(); // æ›´æ–°æ„›å¿ƒæ‹¾å–

					// æ­¦å™¨å¾Œåº§åŠ›æ¢å¾©
					weaponRecoil *= 0.8;
					drawWeapon();
					drawMinimap();

					// è¢å¹•éœ‡å‹•æ•ˆæœ
					if (screenShake > 0) {
						camera.rotation.z = (Math.random() - 0.5) * screenShake * 0.01;
						screenShake *= 0.9;
						if (screenShake < 0.1) {
							screenShake = 0;
							camera.rotation.z = 0;
						}
					} else {
						// ç¢ºä¿è¦–è§’æ°¸é ç›´ç«‹ (z rotation = 0)
						camera.rotation.z = 0;
					}

					// è¡åˆºæ™‚çš„é€Ÿåº¦ç·šæ•ˆæœ
					const speedLines = document.getElementById('speedLines');
					if (player.isSprinting && (keys['KeyW'] || keys['KeyS'] || keys['KeyA'] || keys['KeyD'])) {
						speedLines.style.opacity = '0.5';
					} else {
						speedLines.style.opacity = '0';
					}

					// æ›´æ–°è¡€æ¢
					document.getElementById('healthBarFill').style.width = player.health + '%';

					if (isPointerLocked && keys['Mouse0']) shoot();
				}

				renderer.render(scene, camera);
			}

			function startGame() {
				document.getElementById('startScreen').style.display = 'none';
				gameStarted = true;
				gameOver = false;
				difficulty = 1;
				renderer.domElement.requestPointerLock();
				spawnTargets(); // ç”Ÿæˆæ¨™é¶
				spawnEnemies(); // ç”Ÿæˆæ•µäºº
			}

			function endGame() {
				gameOver = true;

				// åœæ­¢ç”Ÿæˆè¨ˆæ™‚å™¨
				if (spawnTimer) {
					clearInterval(spawnTimer);
					spawnTimer = null;
				}

				document.exitPointerLock();
				document.getElementById('finalWave').textContent = waveNumber;
				document.getElementById('finalKills').textContent = player.kills;
				document.getElementById('finalScore').textContent = totalScore;
				document.getElementById('gameOverScreen').style.display = 'flex';
			}

			function restartGame() {
				// æ¸…é™¤è¨ˆæ™‚å™¨
				if (spawnTimer) {
					clearInterval(spawnTimer);
					spawnTimer = null;
				}

				// é‡ç½®éŠæˆ²çµæŸç•«é¢æ¨™é¡Œï¼ˆå¯èƒ½æ˜¯å‹åˆ©ç•«é¢ï¼‰
				const gameOverScreen = document.getElementById('gameOverScreen');
				gameOverScreen.querySelector('h1').textContent = 'YOU DIED';
				gameOverScreen.querySelector('h1').style.color = '#f00';

				targets.forEach(t => scene.remove(t));
				targets = [];
				enemies.forEach(e => scene.remove(e));
				enemies = [];
				bullets.forEach(b => scene.remove(b));
				bullets = [];
				rockets.forEach(r => scene.remove(r));
				rockets = [];
				smgBullets.forEach(b => scene.remove(b));
				smgBullets = [];
				enemyProjectiles.forEach(p => scene.remove(p));
				enemyProjectiles = [];
				rocketTrails.forEach(t => scene.remove(t));
				rocketTrails = [];

				player.health = 100;
				player.armor = 50;
				player.ammo = 30;
				player.rocketAmmo = 10;
				player.grenadeAmmo = 5;
				player.kills = 0;
				player.isReloading = false;
				player.velocity = { x: 0, y: 0, z: 0 };
				player.onGround = true;
				player.currentWeapon = 1;
				difficulty = 1;
				killStreak = 0;
				roundScore = 0;
				totalScore = 0;
				waveNumber = 0; // é‡ç½®æ³¢æ¬¡
				waveKills = 0;
				waveKillTarget = 0;

				// å‡ºç”Ÿåœ¨å®¤å…§å®‰å…¨ä½ç½® (é¿é–‹æ‰€æœ‰å‚·å®³å€)
				camera.position.set(15, player.height, -15);
				cameraYaw = Math.PI / 4; // é¢å‘ä¸­å¤®
				cameraPitch = 0;
				camera.rotation.order = 'YXZ';
				camera.rotation.y = cameraYaw;
				camera.rotation.x = cameraPitch;
				camera.rotation.z = 0;

				// é‡æ–°éš¨æ©Ÿç”Ÿæˆå‚·å®³å€
				spawnRandomDamageZones();

				gameOver = false;
				updateHUD();
				switchWeapon(1); // é‡ç½®ç‚º SMG

				document.getElementById('gameOverScreen').style.display = 'none';
				renderer.domElement.requestPointerLock();
				spawnTargets(); // ç”Ÿæˆæ¨™é¶
				spawnEnemies(); // ç”Ÿæˆæ•µäºº
			}

			init();
		</script>
	</body>
</html>
