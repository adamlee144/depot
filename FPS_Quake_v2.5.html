<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Quake Style FPS v2.5</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        canvas { display: block; }
        #crosshair {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: #0f0; box-shadow: 0 0 5px #0f0;
        }
        #crosshair::before { width: 20px; height: 2px; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        #crosshair::after { width: 2px; height: 20px; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        #hud {
            position: fixed; bottom: 0; left: 0; right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            padding: 20px;
            z-index: 100; pointer-events: none;
            display: flex; justify-content: space-between; align-items: flex-end;
        }
        .hud-panel {
            background: rgba(80, 40, 0, 0.8);
            border: 3px solid #c80;
            padding: 10px 20px;
            color: #fc0;
            text-shadow: 0 0 10px #f80;
            font-size: 24px;
            font-weight: bold;
        }
        .hud-panel span { color: #fff; font-size: 32px; }
        #scoreBoard {
            position: fixed; top: 20px; left: 50%;
            transform: translateX(-50%);
            color: #fc0; font-size: 20px; text-align: center;
            text-shadow: 0 0 10px #f80;
            z-index: 100; pointer-events: none;
        }
        #damageOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 99;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(255,0,0,0) 100%);
            opacity: 0; transition: opacity 0.1s;
        }
        #startScreen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #1a0a00 0%, #3d1a00 50%, #1a0a00 100%);
            display: flex; flex-direction: row; align-items: center; justify-content: center;
            z-index: 200; color: #fff; padding: 20px;
        }
        #startScreen .left-panel {
            flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 20px;
        }
        #startScreen .right-panel {
            flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 20px;
        }
        #startScreen h1 {
            font-size: 64px;
            color: #f60;
            text-shadow: 0 0 30px #f00, 0 0 60px #f00, 0 5px 10px #000;
            margin-bottom: 5px;
            letter-spacing: 8px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { text-shadow: 0 0 30px #f00, 0 0 60px #f00; }
            50% { text-shadow: 0 0 50px #ff0, 0 0 100px #f80; }
        }
        #startScreen h2 {
            font-size: 20px; color: #c80; margin-bottom: 20px;
        }
        #startScreen .instructions {
            font-size: 14px; line-height: 1.8; margin-bottom: 20px;
            text-align: left; color: #fa0;
            background: rgba(0,0,0,0.5); padding: 15px 25px; border: 2px solid #840;
            max-height: 80vh; overflow-y: auto;
        }
        #startScreen .instructions p { margin: 3px 0; }
        #startScreen .instructions span { color: #0f0; font-weight: bold; }
        #startScreen .features {
            font-size: 14px; line-height: 1.8;
            text-align: left; color: #fa0;
            background: rgba(0,0,0,0.5); padding: 15px 25px; border: 2px solid #840;
        }
        #startScreen .features p { margin: 3px 0; }
        #startScreen button {
            padding: 15px 50px; font-size: 24px;
            background: linear-gradient(180deg, #f60, #800);
            color: #fff; border: 3px solid #fc0; cursor: pointer;
            text-shadow: 0 2px 5px #000;
            font-family: 'Courier New', monospace; font-weight: bold;
            animation: buttonGlow 1.5s infinite;
            margin-top: 20px;
        }
        @keyframes buttonGlow {
            0%, 100% { box-shadow: 0 0 20px #f60; }
            50% { box-shadow: 0 0 40px #ff0, 0 0 60px #f80; }
        }
        #startScreen button:hover { transform: scale(1.1); }
        #gameOverScreen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(20,0,0,0.95);
            display: none; flex-direction: column; align-items: center; justify-content: center;
            z-index: 200; color: #fff;
        }
        #gameOverScreen h1 { font-size: 64px; color: #f00; text-shadow: 0 0 30px #f00; margin-bottom: 20px; }
        #gameOverScreen button {
            padding: 15px 50px; font-size: 24px; margin-top: 20px;
            background: linear-gradient(180deg, #f60, #800);
            color: #fff; border: 2px solid #fc0; cursor: pointer;
        }
        #hitMarker {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 40px; color: #f00; z-index: 101; opacity: 0; pointer-events: none;
            text-shadow: 0 0 10px #f00;
        }
        #weapon {
            position: fixed; bottom: 0; right: 50px;
            width: 350px; height: 250px;
            z-index: 98; pointer-events: none;
        }
        #muzzleFlash {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 100px; height: 100px;
            background: radial-gradient(circle, rgba(255,200,0,0.8) 0%, rgba(255,100,0,0.5) 30%, transparent 70%);
            border-radius: 50%;
            z-index: 97; pointer-events: none;
            opacity: 0;
        }
        #message {
            position: fixed; top: 100px; left: 50%;
            transform: translateX(-50%);
            font-size: 32px; color: #0f0;
            text-shadow: 0 0 20px #0f0;
            z-index: 100; opacity: 0;
            transition: opacity 0.3s;
        }
        #minimap {
            position: fixed; top: 20px; right: 20px;
            width: 150px; height: 150px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #f80;
            border-radius: 5px;
            z-index: 100;
        }
        #killStreak {
            position: fixed; top: 60px; left: 50%;
            transform: translateX(-50%);
            font-size: 48px; color: #ff0;
            text-shadow: 0 0 30px #f80, 0 0 60px #f00;
            z-index: 100; opacity: 0;
            transition: opacity 0.3s;
            font-weight: bold;
        }
        #speedLines {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 50;
            background: radial-gradient(ellipse at center, transparent 60%, rgba(0,0,0,0.3) 100%);
            opacity: 0;
            transition: opacity 0.2s;
        }
        #healthBar {
            position: fixed; bottom: 80px; left: 20px;
            width: 200px; height: 8px;
            background: #333;
            border: 1px solid #666;
            z-index: 100;
        }
        #healthBarFill {
            height: 100%;
            background: linear-gradient(90deg, #f00, #ff0);
            transition: width 0.3s;
        }
        .combo-text {
            position: fixed;
            font-size: 24px;
            color: #ff0;
            text-shadow: 0 0 10px #f80;
            pointer-events: none;
            z-index: 100;
            animation: floatUp 1s ease-out forwards;
        }
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="hitMarker">âœ–</div>
    <div id="muzzleFlash"></div>
    <div id="message"></div>
    <div id="killStreak"></div>
    <div id="speedLines"></div>
    <canvas id="minimap"></canvas>
    <div id="healthBar"><div id="healthBarFill"></div></div>
    <canvas id="weapon"></canvas>
    <div id="hud">
        <div class="hud-panel">HEALTH <span id="health">100</span></div>
        <div class="hud-panel" id="weaponPanel">ğŸ”« SMG <span id="ammo">30</span>/<span id="maxAmmo">30</span></div>
        <div class="hud-panel" id="rocketPanel" style="opacity:0.5">ğŸš€ RPG <span id="rocketAmmo">10</span></div>
    </div>
    <div id="scoreBoard">
        <div>ROUND: <span id="roundScore">0</span> | TOTAL: <span id="totalScore">0</span> | TARGETS: <span id="enemyCount">0</span></div>
    </div>
    <div id="weaponName" style="position:fixed; bottom:120px; right:30px; color:#ff0; font-size:18px; z-index:100;">[ 1 ] SMG</div>
    <div id="damageOverlay"></div>
    <div id="startScreen">
        <div class="left-panel">
            <h1>QUAKE</h1>
            <h2>ğŸ”¥ BROWSER EDITION v2.5 ğŸ”¥</h2>
            <div class="instructions">
                <p><span>W A S D</span> - ç§»å‹•</p>
                <p><span>SPACE</span> - è·³èº</p>
                <p><span>SHIFT</span> - è¡åˆº</p>
                <p><span>æ»‘é¼ </span> - ç„æº–</p>
                <p><span>å·¦éµ</span> - å°„æ“Š</p>
                <p><span>å³éµ / R</span> - æ›å½ˆ</p>
                <p><span>1</span> - è¡é‹’æ§ ğŸ”«</p>
                <p><span>2</span> - ç«ç®­ç ² ğŸš€</p>
            </div>
            <button id="startBtn">â–¶ START GAME</button>
        </div>
        <div class="right-panel">
            <div class="features">
                <p style="color:#ff0; font-size:16px; margin-bottom:10px;">ã€éŠæˆ²ç‰¹è‰²ã€‘</p>
                <p style="color:#f55;">ğŸ¯ æ¨™é¶å››é¢ä¸åŒåˆ†æ•¸ï¼ç„æº–é«˜åˆ†é¢ï¼</p>
                <p style="color:#5ff;">ğŸ’¥ ç«ç®­ç ²çˆ†ç‚¸ç¯„åœå‚·å®³ï¼</p>
                <p style="color:#f80;">ğŸš€ ç«ç®­è·³ï¼å°åœ°å°„æ“Šå¯å½ˆé£› (è‡ªå‚·20é»)</p>
                <p style="color:#0ff;">â¬†ï¸ è—è‰²å½ˆè·³æ¿ = è¶…ç´šè·³èº!</p>
                <p style="color:#f00;">â˜ ï¸ ç´…è‰²åœ°æ¿ = å‚·å®³å€åŸŸ (éš¨æ©Ÿä½ç½®)</p>
                <p style="color:#8f8; margin-top:10px;">ğŸŒ³ å¾€å‰æ¢ç´¢æˆ¶å¤–å€åŸŸ!</p>
                <p style="color:#aaf;">ğŸ”ï¸ å®¤å…§å¯†å®¤ + æˆ¶å¤–è‰åœ°</p>
                <p style="color:#ffa;">â˜€ï¸ è—å¤©ç™½é›²ï¼Œé™½å…‰æ™®ç…§</p>
            </div>
        </div>
    </div>
    <div id="gameOverScreen">
        <h1>YOU DIED</h1>
        <div style="font-size:28px;color:#fc0;">KILLS: <span id="finalKills">0</span></div>
        <button id="restartBtn">â–¶ RESTART</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let player = {
            health: 100,
            armor: 50,
            ammo: 30,
            maxAmmo: 30,
            rocketAmmo: 10,
            maxRocketAmmo: 10,
            kills: 0,
            speed: 0.18,
            sprintSpeed: 0.35,
            jumpForce: 0.3,
            velocity: { x: 0, y: 0, z: 0 },
            onGround: true,
            isReloading: false,
            isSprinting: false,
            height: 1.7,
            bobPhase: 0,
            currentWeapon: 1  // 1=è¡é‹’æ§, 2=ç«ç®­ç ²
        };

        let keys = {};
        let isPointerLocked = false;
        let enemies = [];
        let walls = [];
        let floors = [];   // åœ°æ¿ï¼ˆåªç”¨æ–¼å°„ç·šæª¢æ¸¬ï¼Œä¸æ“‹ç§»å‹•ï¼‰
        let ramps = [];    // æ–œå¡ï¼ˆåªå½±éŸ¿Yè»¸é«˜åº¦ï¼Œä¸æ“‹XZç§»å‹•ï¼‰
        let targets = [];  // å¯ç ´å£çš„ç®±å­æ¨™é¶
        let bullets = [];  // å­å½ˆè»Œè·¡
        let rockets = [];  // ç«ç®­
        let pickups = [];
        let decals = [];
        let gameStarted = false;
        let gameOver = false;
        let lastShootTime = 0;
        let weaponRecoil = 0;
        let difficulty = 1;
        let killStreak = 0;
        let lastKillTime = 0;
        let screenShake = 0;
        let roundScore = 0;  // æœ¬è¼ªåˆ†æ•¸
        let totalScore = 0;  // ç¸½åˆ†

        // è¦–è§’æ§åˆ¶ - ç”¨ç¨ç«‹è®Šæ•¸é¿å…è¬å‘ç¯€æ­»é–
        let cameraYaw = 0;    // å·¦å³è½‰ (Yè»¸)
        let cameraPitch = 0;  // æŠ¬é ­ä½é ­ (Xè»¸)

        // éŸ³æ•ˆç³»çµ± (ä½¿ç”¨ Web Audio API ç”Ÿæˆ)
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(type) {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            if (type === 'shoot') {
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(150, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'hit') {
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.05);
                gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.05);
            } else if (type === 'kill') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
                oscillator.frequency.setValueAtTime(800, audioCtx.currentTime + 0.1);
                oscillator.frequency.setValueAtTime(1000, audioCtx.currentTime + 0.2);
                gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'hurt') {
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.2);
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.2);
            } else if (type === 'reload') {
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
                oscillator.frequency.setValueAtTime(500, audioCtx.currentTime + 0.15);
                gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'explosion') {
                // çˆ†ç‚¸éŸ³æ•ˆ - ä½é »å™ªéŸ³
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(80, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 0.5);
                gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.5);
            } else if (type === 'jump') {
                // å½ˆè·³éŸ³æ•ˆ - ä¸Šå‡éŸ³èª¿
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.2);
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.3);
            }
        }

        // è²¼åœ–ç”Ÿæˆå™¨
        function createTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            if (type === 'brick') {
                // æš—ç´…è‰²ç£šç‰†è²¼åœ–
                ctx.fillStyle = '#3a2020';
                ctx.fillRect(0, 0, 256, 256);

                const brickH = 32;
                const brickW = 64;
                for (let row = 0; row < 8; row++) {
                    const offset = (row % 2) * (brickW / 2);
                    for (let col = -1; col < 5; col++) {
                        const x = col * brickW + offset;
                        const y = row * brickH;

                        // ç£šå¡Šä¸»é«”
                        const shade = 0.7 + Math.random() * 0.3;
                        ctx.fillStyle = `rgb(${Math.floor(120*shade)}, ${Math.floor(50*shade)}, ${Math.floor(50*shade)})`;
                        ctx.fillRect(x + 2, y + 2, brickW - 4, brickH - 4);

                        // ç£šå¡Šç´‹ç†
                        for (let i = 0; i < 20; i++) {
                            ctx.fillStyle = `rgba(0,0,0,${Math.random()*0.2})`;
                            ctx.fillRect(x + Math.random()*brickW, y + Math.random()*brickH, 3, 3);
                        }
                    }
                    // æ°´å¹³ç¸«éš™
                    ctx.fillStyle = '#1a0808';
                    ctx.fillRect(0, row * brickH, 256, 3);
                }
            } else if (type === 'metal') {
                // é‡‘å±¬åœ°æ¿
                ctx.fillStyle = '#2a2a30';
                ctx.fillRect(0, 0, 256, 256);

                // æ ¼å­ç´‹è·¯
                const gridSize = 64;
                for (let y = 0; y < 4; y++) {
                    for (let x = 0; x < 4; x++) {
                        const shade = 0.8 + Math.random() * 0.2;
                        ctx.fillStyle = `rgb(${Math.floor(50*shade)}, ${Math.floor(55*shade)}, ${Math.floor(60*shade)})`;
                        ctx.fillRect(x * gridSize + 2, y * gridSize + 2, gridSize - 4, gridSize - 4);

                        // é‰šé‡˜
                        ctx.fillStyle = '#555';
                        ctx.beginPath();
                        ctx.arc(x * gridSize + 8, y * gridSize + 8, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(x * gridSize + gridSize - 8, y * gridSize + 8, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(x * gridSize + 8, y * gridSize + gridSize - 8, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(x * gridSize + gridSize - 8, y * gridSize + gridSize - 8, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // åˆ®ç—•
                ctx.strokeStyle = 'rgba(100,100,110,0.3)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 15; i++) {
                    ctx.beginPath();
                    ctx.moveTo(Math.random()*256, Math.random()*256);
                    ctx.lineTo(Math.random()*256, Math.random()*256);
                    ctx.stroke();
                }
            } else if (type === 'ceiling') {
                // å¤©èŠ±æ¿è²¼åœ–
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, 256, 256);

                // ç®¡ç·š/æ¨‘
                ctx.fillStyle = '#252525';
                ctx.fillRect(0, 60, 256, 40);
                ctx.fillRect(0, 160, 256, 40);
                ctx.fillRect(60, 0, 40, 256);
                ctx.fillRect(160, 0, 40, 256);

                // æ±¡æ¼¬
                for (let i = 0; i < 30; i++) {
                    ctx.fillStyle = `rgba(0,0,0,${Math.random()*0.3})`;
                    ctx.beginPath();
                    ctx.arc(Math.random()*256, Math.random()*256, 5+Math.random()*20, 0, Math.PI*2);
                    ctx.fill();
                }
            } else if (type === 'crate') {
                // ç®±å­è²¼åœ–
                ctx.fillStyle = '#5a4030';
                ctx.fillRect(0, 0, 256, 256);

                // æœ¨æ¿ç´‹è·¯
                ctx.fillStyle = '#4a3020';
                for (let i = 0; i < 6; i++) {
                    ctx.fillRect(0, i * 45 + 3, 256, 3);
                }

                // é‚Šæ¡†
                ctx.strokeStyle = '#2a1a10';
                ctx.lineWidth = 8;
                ctx.strokeRect(10, 10, 236, 236);

                // é‡‘å±¬ç‰‡
                ctx.fillStyle = '#666';
                ctx.fillRect(100, 100, 56, 56);
                ctx.fillStyle = '#888';
                ctx.fillRect(105, 105, 46, 46);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        // æè³ª
        let brickTexture, metalTexture, ceilingTexture, crateTexture;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);  // ç™½è‰²å¤©ç©ºèƒŒæ™¯
            scene.fog = new THREE.FogExp2(0xffffff, 0.008);  // ç™½è‰²éœ§ï¼Œè¼ƒæ·¡

            camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(15, player.height, -15);  // å‡ºç”Ÿåœ¨å®¤å…§å®‰å…¨ä½ç½®
            camera.rotation.order = 'YXZ';  // é‡è¦ï¼šé¿å…è¬å‘ç¯€æ­»é–

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // å‰µå»ºè²¼åœ–
            brickTexture = createTexture('brick');
            metalTexture = createTexture('metal');
            ceilingTexture = createTexture('ceiling');
            crateTexture = createTexture('crate');

            // å…‰æº - æ˜äº®ä½†æœ‰æ°£æ°›
            const ambient = new THREE.AmbientLight(0x666666, 0.8);
            scene.add(ambient);

            // ä¸»å…‰æº - æ¨¡æ“¬å¤©èŠ±æ¿ç‡ˆ
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.6);
            mainLight.position.set(0, 10, 0);
            scene.add(mainLight);

            // æ©™ç´…è‰²é»å…‰æºç‡Ÿé€ æˆ°é¬¥æ°›åœ
            const redLight1 = new THREE.PointLight(0xff4400, 1.5, 50);
            redLight1.position.set(20, 6, 20);
            scene.add(redLight1);

            const redLight2 = new THREE.PointLight(0xff4400, 1.5, 50);
            redLight2.position.set(-20, 6, -20);
            scene.add(redLight2);

            const redLight3 = new THREE.PointLight(0xff6600, 1.2, 40);
            redLight3.position.set(0, 6, 0);
            scene.add(redLight3);

            // å››è§’è£œå…‰
            const blueLight1 = new THREE.PointLight(0x4488ff, 0.6, 35);
            blueLight1.position.set(35, 5, 35);
            scene.add(blueLight1);

            const blueLight2 = new THREE.PointLight(0x4488ff, 0.6, 35);
            blueLight2.position.set(-35, 5, -35);
            scene.add(blueLight2);

            // ç©å®¶æ‰‹é›»ç­’ - æ›´äº®
            const flashlight = new THREE.SpotLight(0xffffee, 1.2, 60, Math.PI/5, 0.3);
            flashlight.position.set(0, 0, 0);
            camera.add(flashlight);
            flashlight.target.position.set(0, 0, -1);
            camera.add(flashlight.target);
            scene.add(camera);

            createMap();
            setupEvents();
            drawWeapon();
            drawMinimap();
            animate();
        }

        // å‚·å®³åœ°æ¿å’Œå½ˆè·³å€é™£åˆ—
        let damageZones = [];
        let jumpPads = [];
        let damageZoneMeshes = [];  // ç”¨æ–¼é‡ç½®æ™‚æ¸…é™¤

        function createMap() {
            const ceilingHeight = 20;  // å®¤å…§å¤©èŠ±æ¿é«˜åº¦
            const indoorSize = 100;    // å®¤å…§å€åŸŸå¤§å°
            const outdoorSize = 100;   // æˆ¶å¤–å€åŸŸå¤§å°

            // ========== å‰µå»ºå¤©ç©ºç›’ (æˆ¶å¤–èƒŒæ™¯) ==========
            createSkybox();

            // ========== å®¤å…§å€åŸŸ (B1 å¯†å®¤) ==========
            // å®¤å…§é‡‘å±¬åœ°æ¿
            metalTexture.repeat.set(20, 20);
            const indoorFloorGeo = new THREE.PlaneGeometry(indoorSize, indoorSize);
            const indoorFloorMat = new THREE.MeshLambertMaterial({ map: metalTexture });
            const indoorFloor = new THREE.Mesh(indoorFloorGeo, indoorFloorMat);
            indoorFloor.rotation.x = -Math.PI / 2;
            indoorFloor.position.set(0, 0, 0);
            indoorFloor.receiveShadow = true;
            scene.add(indoorFloor);
            // åŠ å…¥åœ°æ¿é™£åˆ—ï¼ˆåªç”¨æ–¼å°„ç·šæª¢æ¸¬ï¼Œä¸å½±éŸ¿ç§»å‹•ï¼‰
            floors.push({ mesh: indoorFloor, box: new THREE.Box3().setFromObject(indoorFloor) });

            // å®¤å…§å¤©èŠ±æ¿
            ceilingTexture.repeat.set(15, 15);
            const indoorCeilingGeo = new THREE.PlaneGeometry(indoorSize, indoorSize);
            const indoorCeilingMat = new THREE.MeshLambertMaterial({ map: ceilingTexture });
            const indoorCeiling = new THREE.Mesh(indoorCeilingGeo, indoorCeilingMat);
            indoorCeiling.rotation.x = Math.PI / 2;
            indoorCeiling.position.set(0, ceilingHeight, 0);
            scene.add(indoorCeiling);

            // å®¤å…§ç‰†å£ (ä¸‰é¢å°é–‰ï¼Œä¸€é¢æœ‰å‡ºå£é€šå¾€æˆ¶å¤–)
            createWall(0, ceilingHeight/2, -50, 100, ceilingHeight, 1, 'brick', [25, 2]);  // å¾Œç‰†
            createWall(-50, ceilingHeight/2, 0, 1, ceilingHeight, 100, 'brick', [25, 2]); // å·¦ç‰†
            createWall(50, ceilingHeight/2, 0, 1, ceilingHeight, 100, 'brick', [25, 2]);  // å³ç‰†
            // å‰ç‰†æœ‰å‡ºå£ (å…©æ®µç‰† + ä¸­é–“ç©ºæ´)
            createWall(-35, ceilingHeight/2, 50, 30, ceilingHeight, 1, 'brick', [8, 2]);
            createWall(35, ceilingHeight/2, 50, 30, ceilingHeight, 1, 'brick', [8, 2]);
            // å‡ºå£ä¸Šæ–¹
            createWall(0, ceilingHeight - 3, 50, 40, 6, 1, 'brick', [10, 1]);

            // å®¤å…§çµæ§‹
            createWall(20, 4, 20, 15, 8, 1, 'brick', [4, 1]);
            createWall(20, 4, -20, 15, 8, 1, 'brick', [4, 1]);
            createWall(-20, 4, 20, 15, 8, 1, 'brick', [4, 1]);
            createWall(-20, 4, -20, 15, 8, 1, 'brick', [4, 1]);
            createWall(35, 4, 0, 1, 8, 25, 'brick', [6, 1]);
            createWall(-35, 4, 0, 1, 8, 25, 'brick', [6, 1]);
            createWall(0, 4, -35, 25, 8, 1, 'brick', [6, 1]);

            // ä¸­å¤®æŸ±å­
            createWall(0, ceilingHeight/2, 0, 4, ceilingHeight, 4, 'brick', [1, 2]);

            // å®¤å…§ç®±å­
            createCrate(15, 1.5, 0, 3, 3, 3);
            createCrate(-15, 1.5, 0, 3, 3, 3);
            createCrate(0, 1.5, -15, 3, 3, 3);
            createCrate(30, 1, -30, 2, 2, 2);
            createCrate(30, 3, -30, 2, 2, 2);
            createCrate(-30, 1, -30, 2, 2, 2);

            // å®¤å…§é«˜å°
            createCrate(20, 6, 0, 6, 1, 6);
            createCrate(-20, 6, 0, 6, 1, 6);
            createCrate(0, 6, -20, 6, 1, 6);

            // ========== å®¤å…§å±‹é ‚ (å¯¦å¿ƒå°é ‚ï¼Œå¾å¤–é¢çœ‹æ˜¯å»ºç¯‰ç‰©) ==========
            // å±‹é ‚å¹³å° - å¯ä»¥ç«™ä¸Šå»
            const roofTex = createTexture('brick');
            roofTex.repeat.set(20, 20);
            const roofGeo = new THREE.BoxGeometry(100, 2, 100);
            const roofMat = new THREE.MeshLambertMaterial({ map: roofTex });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.set(0, ceilingHeight + 1, 0);  // å¤©èŠ±æ¿ä¸Šæ–¹
            roof.castShadow = true;
            roof.receiveShadow = true;
            scene.add(roof);
            walls.push({ mesh: roof, box: new THREE.Box3().setFromObject(roof) });

            // å±‹é ‚è­·æ¬„ (å››å‘¨çŸ®ç‰†)
            const roofFenceH = 1.5;
            createWall(0, ceilingHeight + 2 + roofFenceH/2, -49, 100, roofFenceH, 1, 'brick', [25, 1]);
            createWall(0, ceilingHeight + 2 + roofFenceH/2, 49, 100, roofFenceH, 1, 'brick', [25, 1]);
            createWall(-49, ceilingHeight + 2 + roofFenceH/2, 0, 1, roofFenceH, 100, 'brick', [25, 1]);
            createWall(49, ceilingHeight + 2 + roofFenceH/2, 0, 1, roofFenceH, 100, 'brick', [25, 1]);

            // ========== æˆ¶å¤–å€åŸŸ ==========
            // æˆ¶å¤–è‰åœ°
            const grassTex = createGrassTexture();
            grassTex.repeat.set(20, 20);
            const outdoorFloorGeo = new THREE.PlaneGeometry(outdoorSize, outdoorSize);
            const outdoorFloorMat = new THREE.MeshLambertMaterial({ map: grassTex });
            const outdoorFloor = new THREE.Mesh(outdoorFloorGeo, outdoorFloorMat);
            outdoorFloor.rotation.x = -Math.PI / 2;
            outdoorFloor.position.set(0, 0, 100);  // æˆ¶å¤–åœ¨ Z+ æ–¹å‘
            outdoorFloor.receiveShadow = true;
            scene.add(outdoorFloor);
            // åŠ å…¥åœ°æ¿é™£åˆ—ï¼ˆåªç”¨æ–¼å°„ç·šæª¢æ¸¬ï¼Œä¸å½±éŸ¿ç§»å‹•ï¼‰
            floors.push({ mesh: outdoorFloor, box: new THREE.Box3().setFromObject(outdoorFloor) });

            // æˆ¶å¤–åœç‰† (åŠ é«˜åˆ°èƒ½åŒ…åœå±‹é ‚æ–œå¡)
            const fenceHeight = 30;
            createWall(0, fenceHeight/2, 150, 100, fenceHeight, 1, 'brick', [25, 3]);  // é ç«¯ç‰†
            createWall(-50, fenceHeight/2, 100, 1, fenceHeight, 100, 'brick', [25, 3]); // å·¦ç‰†
            createWall(50, fenceHeight/2, 100, 1, fenceHeight, 100, 'brick', [25, 3]);  // å³ç‰†

            // ========== æ–œå¡é€šå¾€å±‹é ‚ ==========
            // æ–œå¡ï¼šå¾åœ°é¢(y=0, z=60)åˆ°å±‹é ‚(y=22, z=50)
            // æ–œå¡å¾ z=90 é–‹å§‹å¾€å®¤å…§æ–¹å‘çˆ¬å‡åˆ° z=50 (å±‹é ‚é‚Šç·£)
            createRamp(-40, 90, ceilingHeight + 2);  // å·¦å´æ–œå¡

            // æˆ¶å¤–è£é£¾ - å²©çŸ³
            createRock(-30, 100);
            createRock(25, 120);
            createRock(-15, 135);
            createRock(35, 90);

            // æˆ¶å¤–ç®±å­
            createCrate(0, 1.5, 80, 3, 3, 3);
            createCrate(-20, 1.5, 110, 3, 3, 3);
            createCrate(20, 1.5, 130, 3, 3, 3);

            // æˆ¶å¤–é«˜å° - ç­æœ›å¡”
            createCrate(0, 3, 120, 4, 6, 4);
            createCrate(0, 7, 120, 6, 1, 6);

            // å±‹é ‚ä¼‘æ¯å€
            createCrate(0, ceilingHeight + 3.5, 0, 8, 1, 8);  // å±‹é ‚ä¸­å¤®å¹³å°
            createCrate(30, ceilingHeight + 3.5, -30, 5, 1, 5);  // å±‹é ‚è§’è½å¹³å°

            // ========== å½ˆè·³å€ (å¢åŠ åˆ°16å€‹) ==========
            const jumpPadPositions = [
                // å®¤å…§
                [25, 25], [-25, 25], [25, -25], [-25, -25],
                [40, 0], [-40, 0], [0, -40],
                [10, 35], [-10, 35],  // å‡ºå£é™„è¿‘
                // æˆ¶å¤–
                [0, 70], [30, 100], [-30, 100],
                [0, 130], [40, 130], [-40, 130],
                [0, 100],  // ä¸­å¤®
            ];
            jumpPadPositions.forEach(([x, z]) => createJumpPad(x, z));

            // ========== å‚·å®³å€ (æ¸›å°‘åˆ°4å€‹ï¼Œéš¨æ©Ÿä½ç½®) ==========
            spawnRandomDamageZones();

            // å²©æ¼¿æ± åªä¿ç•™2å€‹åœ¨å®¤å…§è§’è½
            const lavaGeo = new THREE.PlaneGeometry(6, 6);
            const lavaMat = new THREE.MeshBasicMaterial({ color: 0xff2200 });
            [[-40, -40], [40, -40]].forEach(([x, z]) => {
                const lava = new THREE.Mesh(lavaGeo, lavaMat);
                lava.rotation.x = -Math.PI / 2;
                lava.position.set(x, 0.01, z);
                scene.add(lava);
                const lavaLight = new THREE.PointLight(0xff4400, 0.8, 15);
                lavaLight.position.set(x, 1, z);
                scene.add(lavaLight);
                damageZones.push({ x: x, z: z, radius: 4, damage: 3, type: 'lava' });
            });

            // æˆ¶å¤–é™½å…‰
            const sunLight = new THREE.DirectionalLight(0xffffcc, 1);
            sunLight.position.set(50, 100, 150);
            sunLight.castShadow = true;
            scene.add(sunLight);
        }

        // å‰µå»ºå¤©ç©ºç›’ - æ˜äº®çš„ç™½å¤©æ•ˆæœ
        function createSkybox() {
            // ç›´æ¥ç”¨ç´”ç™½è‰²å¤©ç©º
            const skyGeo = new THREE.SphereGeometry(500, 32, 32);
            const skyMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,  // ç´”ç™½è‰²
                side: THREE.BackSide  // å…§å´å¯è¦‹
            });
            const sky = new THREE.Mesh(skyGeo, skyMat);
            scene.add(sky);
        }

        // å‰µå»ºè‰åœ°è²¼åœ–
        function createGrassTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // åŸºåº•ç¶ è‰²
            ctx.fillStyle = '#3a7a30';
            ctx.fillRect(0, 0, 256, 256);

            // æ·»åŠ è‰çš„ç´‹ç†
            for (let i = 0; i < 500; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                const shade = 0.7 + Math.random() * 0.6;
                ctx.fillStyle = `rgb(${Math.floor(50*shade)}, ${Math.floor(130*shade)}, ${Math.floor(40*shade)})`;
                ctx.fillRect(x, y, 2, 4 + Math.random() * 4);
            }

            // ä¸€äº›æ·±è‰²æ–‘é»
            for (let i = 0; i < 50; i++) {
                ctx.fillStyle = `rgba(20, 60, 20, ${0.3 + Math.random() * 0.3})`;
                ctx.beginPath();
                ctx.arc(Math.random() * 256, Math.random() * 256, 3 + Math.random() * 8, 0, Math.PI * 2);
                ctx.fill();
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        // å‰µå»ºæˆ¶å¤–å²©çŸ³
        function createRock(x, z) {
            const rockGeo = new THREE.DodecahedronGeometry(2 + Math.random() * 2, 1);
            const rockMat = new THREE.MeshLambertMaterial({ color: 0x666666 });
            const rock = new THREE.Mesh(rockGeo, rockMat);
            rock.position.set(x, 1, z);
            rock.rotation.set(Math.random(), Math.random(), Math.random());
            rock.scale.set(1, 0.6 + Math.random() * 0.4, 1);
            rock.castShadow = true;
            scene.add(rock);
            walls.push({ mesh: rock, box: new THREE.Box3().setFromObject(rock) });
        }

        // å‰µå»ºæ–œå¡é€šå¾€å±‹é ‚ - ä½¿ç”¨è¦–è¦ºæ–œå¡ + é‚è¼¯é«˜åº¦å€
        function createRamp(x, startZ, targetHeight) {
            const rampWidth = 10;      // æ–œå¡å¯¬åº¦
            const rampLength = 40;     // æ–œå¡é•·åº¦ï¼ˆç¸®çŸ­è®“å¡åº¦åˆç†ï¼‰
            const endZ = startZ - rampLength;

            // è¦–è¦ºæ–œå¡ - ç”¨ BoxGeometry æ—‹è½‰
            const rampThickness = 1;
            const rampDiagonal = Math.sqrt(rampLength * rampLength + targetHeight * targetHeight);
            const rampGeo = new THREE.BoxGeometry(rampWidth, rampThickness, rampDiagonal);
            const rampTex = createTexture('brick');
            rampTex.repeat.set(2, 10);
            const rampMat = new THREE.MeshLambertMaterial({ map: rampTex });
            const rampMesh = new THREE.Mesh(rampGeo, rampMat);

            // è¨ˆç®—è§’åº¦å’Œä½ç½®
            // æ–œå¡å¾ startZ (ä½ç«¯y=0) å¾€ endZ (é«˜ç«¯y=targetHeight) ä¸Šå‡
            // è§’åº¦ç‚ºæ­£è¡¨ç¤º Z æ¸›å°‘æ™‚ Y å¢åŠ 
            const angle = Math.atan2(targetHeight, rampLength);
            rampMesh.rotation.x = angle;  // æ­£è§’åº¦ï¼šZæ¸›å°‘æ™‚Yå¢åŠ 
            rampMesh.position.set(x, targetHeight / 2, (startZ + endZ) / 2);
            rampMesh.castShadow = true;
            rampMesh.receiveShadow = true;
            scene.add(rampMesh);

            // æ–œå¡ç”¨æ–¼å°„ç·šæª¢æ¸¬ï¼ˆå­å½ˆå¯ä»¥æ‰“åˆ°ï¼‰
            floors.push({ mesh: rampMesh, box: new THREE.Box3().setFromObject(rampMesh) });

            // è¨»å†Šæ–œå¡é‚è¼¯å€åŸŸï¼ˆç”¨æ–¼è¨ˆç®—ç©å®¶è…³ä¸‹é«˜åº¦ï¼‰
            ramps.push({
                x: x,
                z1: startZ,      // æ–œå¡èµ·é» (ä½ç«¯, y=0)
                z2: endZ,        // æ–œå¡çµ‚é» (é«˜ç«¯, y=targetHeight)
                width: rampWidth,
                height: targetHeight,
                // è¨ˆç®—æŸå€‹Zä½ç½®çš„é«˜åº¦
                getHeight: function(pz) {
                    if (pz > this.z1 || pz < this.z2) return -1; // ä¸åœ¨æ–œå¡ç¯„åœ
                    const progress = (this.z1 - pz) / (this.z1 - this.z2);
                    return progress * this.height;
                }
            });

            // æ–œå¡å…©å´è­·æ¬„
            const railMat = new THREE.MeshLambertMaterial({ color: 0x666666 });
            const railHeight = 1.5;
            const railGeo = new THREE.BoxGeometry(0.2, railHeight, rampDiagonal);

            const railL = new THREE.Mesh(railGeo, railMat);
            railL.rotation.x = angle;  // èˆ‡æ–œå¡åŒæ–¹å‘
            railL.position.set(x - rampWidth/2 - 0.15, targetHeight/2 + railHeight/2, (startZ + endZ) / 2);
            scene.add(railL);

            const railR = new THREE.Mesh(railGeo, railMat);
            railR.rotation.x = angle;  // èˆ‡æ–œå¡åŒæ–¹å‘
            railR.position.set(x + rampWidth/2 + 0.15, targetHeight/2 + railHeight/2, (startZ + endZ) / 2);
            scene.add(railR);

            // æ–œå¡åº•éƒ¨ç®­é ­æ¨™è¨˜
            const arrowCanvas = document.createElement('canvas');
            arrowCanvas.width = 64;
            arrowCanvas.height = 64;
            const ctx = arrowCanvas.getContext('2d');
            ctx.fillStyle = '#ffcc00';
            ctx.beginPath();
            ctx.moveTo(32, 5);
            ctx.lineTo(55, 45);
            ctx.lineTo(40, 45);
            ctx.lineTo(40, 60);
            ctx.lineTo(24, 60);
            ctx.lineTo(24, 45);
            ctx.lineTo(9, 45);
            ctx.closePath();
            ctx.fill();

            const arrowTex = new THREE.CanvasTexture(arrowCanvas);
            const arrowMat = new THREE.MeshBasicMaterial({ map: arrowTex, transparent: true });
            const arrowGeo = new THREE.PlaneGeometry(4, 4);
            const arrow = new THREE.Mesh(arrowGeo, arrowMat);
            arrow.rotation.x = -Math.PI / 2;
            arrow.position.set(x, 0.15, startZ + 3);
            scene.add(arrow);
        }

        // éš¨æ©Ÿç”Ÿæˆå‚·å®³å€ (é¿é–‹å‡ºç”Ÿé»)
        function spawnRandomDamageZones() {
            // æ¸…é™¤èˆŠçš„å‚·å®³å€
            damageZoneMeshes.forEach(mesh => scene.remove(mesh));
            damageZoneMeshes = [];
            // åªä¿ç•™å²©æ¼¿å€
            damageZones = damageZones.filter(z => z.type === 'lava');

            // å¯ç”¨ä½ç½®æ±  (é¿é–‹å‡ºç”Ÿé» 10,1.7,10 é™„è¿‘)
            const possiblePositions = [
                // å®¤å…§
                [-25, -25, 5, 5],
                [25, -25, 5, 5],
                [-30, 10, 5, 5],
                [30, 10, 5, 5],
                // æˆ¶å¤–
                [-20, 90, 5, 5],
                [20, 90, 5, 5],
                [0, 140, 6, 6],
                [-35, 120, 5, 5],
            ];

            // éš¨æ©Ÿé¸4å€‹
            const shuffled = possiblePositions.sort(() => Math.random() - 0.5);
            const selected = shuffled.slice(0, 4);

            selected.forEach(([x, z, w, d]) => {
                createDamageZone(x, z, w, d);
            });
        }

        // å‰µå»ºå‚·å®³åœ°æ¿
        function createDamageZone(x, z, w, d) {
            // å‚·å®³åœ°æ¿è¦–è¦ºæ•ˆæœ
            const zoneGeo = new THREE.PlaneGeometry(w, d);

            // å‰µå»ºè­¦å‘Šæ¢ç´‹è²¼åœ–
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // é»‘é»ƒæ¢ç´‹
            ctx.fillStyle = '#220000';
            ctx.fillRect(0, 0, 64, 64);
            ctx.fillStyle = '#ff0000';
            for (let i = 0; i < 8; i++) {
                ctx.fillRect(i * 16, 0, 8, 64);
            }
            // éª·é«æ¨™èªŒ
            ctx.fillStyle = '#ffff00';
            ctx.font = 'bold 30px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('â˜ ', 32, 45);

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(w/4, d/4);

            const zoneMat = new THREE.MeshBasicMaterial({
                map: tex,
                transparent: true,
                opacity: 0.8
            });
            const zone = new THREE.Mesh(zoneGeo, zoneMat);
            zone.rotation.x = -Math.PI / 2;
            zone.position.set(x, 0.02, z);
            scene.add(zone);
            damageZoneMeshes.push(zone);  // è¿½è¹¤ä»¥ä¾¿é‡ç½®

            // ç´…è‰²è­¦å‘Šå…‰
            const light = new THREE.PointLight(0xff0000, 0.5, 10);
            light.position.set(x, 0.5, z);
            scene.add(light);
            damageZoneMeshes.push(light);  // è¿½è¹¤å…‰æº

            // å„²å­˜å‚·å®³å€è³‡è¨Š
            damageZones.push({
                x: x, z: z,
                w: w, d: d,
                damage: 2,
                type: 'floor'
            });
        }

        // å‰µå»ºåé‡åŠ›å½ˆè·³å€
        function createJumpPad(x, z) {
            const padSize = 3;

            // å½ˆè·³æ¿åŸºåº§
            const baseGeo = new THREE.CylinderGeometry(padSize/2, padSize/2 + 0.3, 0.3, 16);
            const baseMat = new THREE.MeshLambertMaterial({ color: 0x333366 });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.position.set(x, 0.15, z);
            scene.add(base);

            // ç™¼å…‰åœ“ç›¤
            const padGeo = new THREE.CylinderGeometry(padSize/2 - 0.2, padSize/2 - 0.2, 0.1, 16);
            const padMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.7
            });
            const pad = new THREE.Mesh(padGeo, padMat);
            pad.position.set(x, 0.35, z);
            pad.userData = { glowPhase: Math.random() * Math.PI * 2 };
            scene.add(pad);

            // å‘ä¸Šç®­é ­æ¨™èªŒ
            const arrowCanvas = document.createElement('canvas');
            arrowCanvas.width = 64;
            arrowCanvas.height = 64;
            const ctx = arrowCanvas.getContext('2d');
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.moveTo(32, 5);
            ctx.lineTo(55, 40);
            ctx.lineTo(40, 40);
            ctx.lineTo(40, 60);
            ctx.lineTo(24, 60);
            ctx.lineTo(24, 40);
            ctx.lineTo(9, 40);
            ctx.closePath();
            ctx.fill();

            const arrowTex = new THREE.CanvasTexture(arrowCanvas);
            const arrowMat = new THREE.MeshBasicMaterial({
                map: arrowTex,
                transparent: true,
                side: THREE.DoubleSide
            });
            const arrowGeo = new THREE.PlaneGeometry(1.5, 1.5);
            const arrow = new THREE.Mesh(arrowGeo, arrowMat);
            arrow.rotation.x = -Math.PI / 2;
            arrow.position.set(x, 0.4, z);
            scene.add(arrow);

            // è—è‰²å…‰æº
            const light = new THREE.PointLight(0x00ffff, 1, 8);
            light.position.set(x, 1, z);
            scene.add(light);

            // å„²å­˜å½ˆè·³å€è³‡è¨Š
            jumpPads.push({
                x: x, z: z,
                radius: padSize/2,
                jumpForce: 0.8,  // å¼·åŠ›å½ˆè·³
                pad: pad,
                light: light
            });
        }

        function createWall(x, y, z, w, h, d, texType, repeat) {
            const geo = new THREE.BoxGeometry(w, h, d);
            let mat;

            if (texType === 'brick') {
                const tex = createTexture('brick');
                tex.repeat.set(repeat[0], repeat[1]);
                mat = new THREE.MeshLambertMaterial({ map: tex });
            } else {
                mat = new THREE.MeshLambertMaterial({ color: 0x5a3030 });
            }

            const wall = new THREE.Mesh(geo, mat);
            wall.position.set(x, y, z);
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
            walls.push({ mesh: wall, box: new THREE.Box3().setFromObject(wall) });
        }

        function createCrate(x, y, z, w, h, d) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const tex = createTexture('crate');
            const mat = new THREE.MeshLambertMaterial({ map: tex });
            const crate = new THREE.Mesh(geo, mat);
            crate.position.set(x, y, z);
            crate.castShadow = true;
            crate.receiveShadow = true;
            scene.add(crate);
            walls.push({ mesh: crate, box: new THREE.Box3().setFromObject(crate) });
        }

        // å‰µå»ºå››é¢åˆ†æ•¸æ¨™é¶çš„è²¼åœ–
        function createTargetFaceTexture(score, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            // èƒŒæ™¯è‰²
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, 128, 128);

            // æ¨™é¶åœ“ç’°
            const rings = score >= 500 ? 4 : score >= 300 ? 3 : score >= 200 ? 2 : 1;
            const ringColors = ['#fff', '#000', '#fff', '#000'];
            for (let i = rings; i >= 0; i--) {
                ctx.fillStyle = ringColors[i % 2];
                ctx.beginPath();
                ctx.arc(64, 64, 50 - i * 10, 0, Math.PI * 2);
                ctx.fill();
            }

            // ä¸­å¿ƒé¶å¿ƒ
            ctx.fillStyle = score >= 500 ? '#FFD700' : score >= 300 ? '#ff0' : score >= 200 ? '#f80' : '#f00';
            ctx.beginPath();
            ctx.arc(64, 64, 15, 0, Math.PI * 2);
            ctx.fill();

            // åˆ†æ•¸æ–‡å­—
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.strokeText(score.toString(), 64, 64);
            ctx.fillText(score.toString(), 64, 64);

            return new THREE.CanvasTexture(canvas);
        }

        // å‰µå»ºå¯ç ´å£çš„æ¨™é¶ç®±å­ - å››é¢ä¸åŒåˆ†æ•¸
        function createTarget(x, y, z) {
            const target = new THREE.Group();

            // å››å€‹é¢çš„åˆ†æ•¸å’Œé¡è‰²
            const faceScores = [100, 200, 300, 500];  // å‰ã€å³ã€å¾Œã€å·¦
            const faceColors = ['#cc4444', '#44cc44', '#4444cc', '#cccc44'];

            // å‰µå»ºç®±å­çš„å…­å€‹é¢
            const boxSize = 1.5;
            const halfSize = boxSize / 2;

            // ä½¿ç”¨å…­å€‹å¹³é¢çµ„æˆç®±å­ï¼Œæ¯é¢å¯ä»¥æœ‰ä¸åŒè²¼åœ–
            const planeGeo = new THREE.PlaneGeometry(boxSize, boxSize);

            // å‰é¢ (Z+) - 100åˆ†
            const frontTex = createTargetFaceTexture(100, faceColors[0]);
            const frontMat = new THREE.MeshBasicMaterial({ map: frontTex });
            const front = new THREE.Mesh(planeGeo, frontMat);
            front.position.z = halfSize;
            front.userData = { faceIndex: 0, score: 100 };
            target.add(front);

            // å¾Œé¢ (Z-) - 300åˆ†
            const backTex = createTargetFaceTexture(300, faceColors[2]);
            const backMat = new THREE.MeshBasicMaterial({ map: backTex });
            const back = new THREE.Mesh(planeGeo, backMat);
            back.position.z = -halfSize;
            back.rotation.y = Math.PI;
            back.userData = { faceIndex: 2, score: 300 };
            target.add(back);

            // å³é¢ (X+) - 200åˆ†
            const rightTex = createTargetFaceTexture(200, faceColors[1]);
            const rightMat = new THREE.MeshBasicMaterial({ map: rightTex });
            const right = new THREE.Mesh(planeGeo, rightMat);
            right.position.x = halfSize;
            right.rotation.y = Math.PI / 2;
            right.userData = { faceIndex: 1, score: 200 };
            target.add(right);

            // å·¦é¢ (X-) - 500åˆ† (é«˜åˆ†é¢!)
            const leftTex = createTargetFaceTexture(500, faceColors[3]);
            const leftMat = new THREE.MeshBasicMaterial({ map: leftTex });
            const left = new THREE.Mesh(planeGeo, leftMat);
            left.position.x = -halfSize;
            left.rotation.y = -Math.PI / 2;
            left.userData = { faceIndex: 3, score: 500 };
            target.add(left);

            // ä¸Šé¢å’Œä¸‹é¢ - ç”¨ç°¡å–®é¡è‰²
            const topGeo = new THREE.PlaneGeometry(boxSize, boxSize);
            const topMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
            const top = new THREE.Mesh(topGeo, topMat);
            top.position.y = halfSize;
            top.rotation.x = -Math.PI / 2;
            target.add(top);

            const bottom = new THREE.Mesh(topGeo, topMat);
            bottom.position.y = -halfSize;
            bottom.rotation.x = Math.PI / 2;
            target.add(bottom);

            target.position.set(x, y, z);

            // ä¸å®šé€Ÿæ—‹è½‰ï¼šé€Ÿåº¦ç¯„åœå¾æ…¢åˆ°å¿«
            const rotateSpeed = (Math.random() * 0.04 + 0.01) * (Math.random() > 0.5 ? 1 : -1);

            target.userData = {
                health: 30,
                maxHealth: 30,
                isTarget: true,
                baseY: y,
                floatPhase: Math.random() * Math.PI * 2,
                rotateSpeed: rotateSpeed,
                faceScores: faceScores  // å„²å­˜åˆ†æ•¸é™£åˆ—ä¾›è¨ˆåˆ†ç”¨
            };

            scene.add(target);
            targets.push(target);
        }

        // ç”Ÿæˆæ¨™é¶
        function spawnTargets() {
            // æ¸…é™¤èˆŠæ¨™é¶
            targets.forEach(t => scene.remove(t));
            targets = [];

            // åœ¨å®¤å…§å’Œæˆ¶å¤–ç”Ÿæˆæ¨™é¶
            const positions = [
                // å®¤å…§å€åŸŸ
                [20, 1.5, 0], [-20, 1.5, 0], [0, 1.5, -20],
                [25, 2, 25], [-25, 2, 25], [25, 2, -25], [-25, 2, -25],
                [15, 3, 15], [-15, 3, 15], [15, 3, -15], [-15, 3, -15],
                [30, 1.5, 10], [-30, 1.5, 10], [30, 1.5, -10], [-30, 1.5, -10],
                // æˆ¶å¤–å€åŸŸ
                [0, 1.5, 75], [20, 2, 85], [-20, 2, 85],
                [30, 1.5, 100], [-30, 1.5, 100], [0, 2, 100],
                [0, 8, 120],  // ç­æœ›å¡”ä¸Š
                [25, 2, 130], [-25, 2, 130], [0, 1.5, 140],
            ];

            const count = Math.min(10 + Math.floor(difficulty * 2), positions.length);
            // éš¨æ©Ÿæ‰“äº‚é †åºå†å–å‰ count å€‹
            const shuffled = positions.sort(() => Math.random() - 0.5);
            for (let i = 0; i < count; i++) {
                const [x, y, z] = shuffled[i];
                createTarget(x, y, z);
            }
            updateEnemyCount();
        }

        // æ›´æ–°æ¨™é¶å‹•ç•«
        function updateTargets() {
            targets.forEach(target => {
                if (target.userData.health <= 0) return;

                // ä¸Šä¸‹æµ®å‹•
                target.userData.floatPhase += 0.03;
                target.position.y = target.userData.baseY + Math.sin(target.userData.floatPhase) * 0.3;

                // ç·©æ…¢æ—‹è½‰
                target.rotation.y += target.userData.rotateSpeed;
            });
        }

        // æ¨™é¶çˆ†ç‚¸æ•ˆæœ
        function explodeTarget(target) {
            const idx = targets.indexOf(target);
            if (idx > -1) {
                targets.splice(idx, 1);

                // å‰µå»ºç¢ç‰‡
                const fragmentCount = 8;
                const fragments = [];
                const color = target.children[0].material.color.getHex();

                for (let i = 0; i < fragmentCount; i++) {
                    const fragGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                    const fragMat = new THREE.MeshLambertMaterial({ color: color });
                    const frag = new THREE.Mesh(fragGeo, fragMat);
                    frag.position.copy(target.position);
                    frag.userData = {
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.3,
                            Math.random() * 0.2 + 0.1,
                            (Math.random() - 0.5) * 0.3
                        ),
                        life: 60
                    };
                    scene.add(frag);
                    fragments.push(frag);
                }

                // ç¢ç‰‡å‹•ç•«
                const animateFragments = () => {
                    let allDead = true;
                    fragments.forEach(frag => {
                        if (frag.userData.life > 0) {
                            allDead = false;
                            frag.position.add(frag.userData.velocity);
                            frag.userData.velocity.y -= 0.01; // é‡åŠ›
                            frag.rotation.x += 0.1;
                            frag.rotation.z += 0.1;
                            frag.userData.life--;

                            // æ·¡å‡º
                            frag.material.opacity = frag.userData.life / 60;
                            frag.material.transparent = true;

                            if (frag.userData.life <= 0) {
                                scene.remove(frag);
                            }
                        }
                    });
                    if (!allDead) {
                        requestAnimationFrame(animateFragments);
                    }
                };
                animateFragments();

                scene.remove(target);
                playSound('kill');

                player.kills++;
                updateHUD();
                updateEnemyCount();

                // é€£æ®º
                const now = Date.now();
                if (now - lastKillTime < 2000) {
                    killStreak++;
                } else {
                    killStreak = 1;
                }
                lastKillTime = now;
                showKillStreak();
                createFloatingText(`+${100 * killStreak}`, window.innerWidth / 2, window.innerHeight / 2 - 50);

                showMessage('TARGET DESTROYED!');

                // å…¨éƒ¨æ‰“å®Œï¼Œç”Ÿæˆæ–°ä¸€æ³¢
                if (targets.length === 0) {
                    difficulty += 0.5;
                    killStreak = 0;
                    showMessage(`WAVE COMPLETE! ROUND SCORE: ${roundScore}`);
                    roundScore = 0;  // é‡ç½®æœ¬è¼ªåˆ†æ•¸
                    updateHUD();
                    setTimeout(() => spawnTargets(), 2000);
                }
            }
        }

        function spawnEnemies() {
            enemies.forEach(e => scene.remove(e));
            enemies = [];

            const count = 6 + Math.floor(difficulty * 2);
            const positions = [
                [35, 35], [-35, 35], [35, -35], [-35, -35],
                [0, 40], [0, -40], [40, 0], [-40, 0],
                [25, 0], [-25, 0], [0, 25], [0, -25]
            ];

            for (let i = 0; i < Math.min(count, positions.length); i++) {
                const [x, z] = positions[i];
                createEnemy(x, z);
            }
            updateEnemyCount();
        }

        function createEnemy(x, z) {
            const enemy = new THREE.Group();

            // éš¨æ©Ÿé¸æ“‡æ•µäººé¡å‹
            const enemyType = Math.floor(Math.random() * 3);
            let bodyColor, headColor, enemyScale;

            if (enemyType === 0) {
                // ç´…è‰²æƒ¡é­”
                bodyColor = 0x8B0000;
                headColor = 0x660000;
                enemyScale = 1;
            } else if (enemyType === 1) {
                // ç¶ è‰²æ®­å±
                bodyColor = 0x2d5a27;
                headColor = 0x1a3d15;
                enemyScale = 1.1;
            } else {
                // è—è‰²å¹½éˆæˆ°å£«
                bodyColor = 0x2a4a6a;
                headColor = 0x1a3a5a;
                enemyScale = 0.9;
            }

            // èº«é«” - è»€å¹¹
            const torsoGeo = new THREE.BoxGeometry(0.6, 0.9, 0.3);
            const torsoMat = new THREE.MeshLambertMaterial({ color: bodyColor });
            const torso = new THREE.Mesh(torsoGeo, torsoMat);
            torso.position.y = 1.2;
            torso.castShadow = true;
            enemy.add(torso);

            // è…°éƒ¨
            const waistGeo = new THREE.BoxGeometry(0.5, 0.3, 0.25);
            const waist = new THREE.Mesh(waistGeo, torsoMat);
            waist.position.y = 0.7;
            enemy.add(waist);

            // é ­éƒ¨
            const headGeo = new THREE.SphereGeometry(0.25, 12, 12);
            const headMat = new THREE.MeshLambertMaterial({ color: headColor });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.9;
            head.castShadow = true;
            head.name = 'head';
            enemy.add(head);

            // é ­ç›”/è§’ (æ ¹æ“šé¡å‹)
            if (enemyType === 0) {
                // æƒ¡é­”è§’
                const hornGeo = new THREE.ConeGeometry(0.06, 0.3, 6);
                const hornMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const hornL = new THREE.Mesh(hornGeo, hornMat);
                hornL.position.set(-0.15, 2.1, 0);
                hornL.rotation.z = 0.3;
                enemy.add(hornL);
                const hornR = new THREE.Mesh(hornGeo, hornMat);
                hornR.position.set(0.15, 2.1, 0);
                hornR.rotation.z = -0.3;
                enemy.add(hornR);
            } else if (enemyType === 1) {
                // æ®­å±ç ´æé ­é«®
                const hairGeo = new THREE.BoxGeometry(0.3, 0.1, 0.2);
                const hairMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                const hair = new THREE.Mesh(hairGeo, hairMat);
                hair.position.set(0, 2.1, -0.05);
                enemy.add(hair);
            } else {
                // æˆ°å£«é ­ç›”
                const helmetGeo = new THREE.SphereGeometry(0.28, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                const helmetMat = new THREE.MeshLambertMaterial({ color: 0x444466 });
                const helmet = new THREE.Mesh(helmetGeo, helmetMat);
                helmet.position.y = 1.95;
                enemy.add(helmet);
            }

            // ç™¼å…‰çœ¼ç›
            const eyeGeo = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeColor = enemyType === 1 ? 0xffff00 : 0xff0000;
            const eyeMat = new THREE.MeshBasicMaterial({ color: eyeColor });
            const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
            eyeL.position.set(-0.08, 1.93, 0.2);
            eyeL.name = 'eyeL';
            enemy.add(eyeL);
            const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
            eyeR.position.set(0.08, 1.93, 0.2);
            eyeR.name = 'eyeR';
            enemy.add(eyeR);

            // å·¦æ‰‹è‡‚ (ä¸Šè‡‚ + å‰è‡‚)
            const armGroup_L = new THREE.Group();
            const upperArmGeo = new THREE.CylinderGeometry(0.08, 0.1, 0.4, 8);
            const armMat = new THREE.MeshLambertMaterial({ color: bodyColor });
            const upperArmL = new THREE.Mesh(upperArmGeo, armMat);
            upperArmL.position.y = -0.2;
            armGroup_L.add(upperArmL);
            const foreArmL = new THREE.Mesh(upperArmGeo, armMat);
            foreArmL.position.y = -0.55;
            armGroup_L.add(foreArmL);
            // æ‰‹
            const handGeo = new THREE.SphereGeometry(0.08, 8, 8);
            const handL = new THREE.Mesh(handGeo, armMat);
            handL.position.y = -0.8;
            armGroup_L.add(handL);
            armGroup_L.position.set(-0.4, 1.5, 0);
            armGroup_L.name = 'armL';
            enemy.add(armGroup_L);

            // å³æ‰‹è‡‚
            const armGroup_R = new THREE.Group();
            const upperArmR = new THREE.Mesh(upperArmGeo, armMat);
            upperArmR.position.y = -0.2;
            armGroup_R.add(upperArmR);
            const foreArmR = new THREE.Mesh(upperArmGeo, armMat);
            foreArmR.position.y = -0.55;
            armGroup_R.add(foreArmR);
            const handR = new THREE.Mesh(handGeo, armMat);
            handR.position.y = -0.8;
            armGroup_R.add(handR);
            armGroup_R.position.set(0.4, 1.5, 0);
            armGroup_R.name = 'armR';
            enemy.add(armGroup_R);

            // å·¦è…¿
            const legGeo = new THREE.CylinderGeometry(0.1, 0.08, 0.5, 8);
            const legMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const legGroup_L = new THREE.Group();
            const upperLegL = new THREE.Mesh(legGeo, legMat);
            upperLegL.position.y = -0.25;
            legGroup_L.add(upperLegL);
            const lowerLegL = new THREE.Mesh(legGeo, legMat);
            lowerLegL.position.y = -0.7;
            legGroup_L.add(lowerLegL);
            // è…³
            const footGeo = new THREE.BoxGeometry(0.12, 0.08, 0.2);
            const footL = new THREE.Mesh(footGeo, legMat);
            footL.position.set(0, -0.95, 0.05);
            legGroup_L.add(footL);
            legGroup_L.position.set(-0.15, 0.55, 0);
            legGroup_L.name = 'legL';
            enemy.add(legGroup_L);

            // å³è…¿
            const legGroup_R = new THREE.Group();
            const upperLegR = new THREE.Mesh(legGeo, legMat);
            upperLegR.position.y = -0.25;
            legGroup_R.add(upperLegR);
            const lowerLegR = new THREE.Mesh(legGeo, legMat);
            lowerLegR.position.y = -0.7;
            legGroup_R.add(lowerLegR);
            const footR = new THREE.Mesh(footGeo, legMat);
            footR.position.set(0, -0.95, 0.05);
            legGroup_R.add(footR);
            legGroup_R.position.set(0.15, 0.55, 0);
            legGroup_R.name = 'legR';
            enemy.add(legGroup_R);

            // æ­¦å™¨ (åªæœ‰æˆ°å£«æœ‰)
            if (enemyType === 2) {
                const swordGeo = new THREE.BoxGeometry(0.05, 0.8, 0.05);
                const swordMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
                const sword = new THREE.Mesh(swordGeo, swordMat);
                sword.position.set(0, -0.5, 0.15);
                armGroup_R.add(sword);
            }

            enemy.scale.set(enemyScale, enemyScale, enemyScale);
            enemy.position.set(x, 0, z);
            enemy.userData = {
                health: 80 + difficulty * 20,
                maxHealth: 80 + difficulty * 20,
                speed: 0.04 + difficulty * 0.01,
                damage: 10 + difficulty * 5,
                lastAttack: 0,
                state: 'idle',
                attackRange: 2.5,
                animPhase: Math.random() * Math.PI * 2,  // å‹•ç•«ç›¸ä½
                enemyType: enemyType
            };
            scene.add(enemy);
            enemies.push(enemy);
        }

        function setupEvents() {
            // éµç›¤äº‹ä»¶ - ç¶å®šåˆ° window ç¢ºä¿èƒ½æ•ç²
            window.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                if (e.code === 'KeyR' && gameStarted && !gameOver) reload();
                if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') player.isSprinting = true;
                // æ­¦å™¨åˆ‡æ›
                if (e.code === 'Digit1' && gameStarted && !gameOver) switchWeapon(1);
                if (e.code === 'Digit2' && gameStarted && !gameOver) switchWeapon(2);
                // é˜²æ­¢æ–¹å‘éµæ²å‹•é é¢
                if (['Space', 'KeyW', 'KeyA', 'KeyS', 'KeyD', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                    e.preventDefault();
                }
            });

            window.addEventListener('keyup', (e) => {
                keys[e.code] = false;
                if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') player.isSprinting = false;
            });

            document.addEventListener('mousemove', (e) => {
                if (!isPointerLocked || !gameStarted || gameOver) return;

                // æ›´æ–° yaw å’Œ pitch
                cameraYaw -= e.movementX * 0.002;
                cameraPitch -= e.movementY * 0.002;

                // é™åˆ¶æŠ¬é ­ä½é ­è§’åº¦ (ä¸èƒ½ç¿»è½‰)
                cameraPitch = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, cameraPitch));

                // ç”¨ Euler é †åº 'YXZ' ä¾†æ­£ç¢ºå¥—ç”¨æ—‹è½‰ï¼Œé¿å… roll
                camera.rotation.order = 'YXZ';
                camera.rotation.y = cameraYaw;
                camera.rotation.x = cameraPitch;
                camera.rotation.z = 0;  // æ°¸é ä¸æ—‹è½‰ Z è»¸
            });

            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
            });

            // æ»‘é¼ äº‹ä»¶
            renderer.domElement.addEventListener('mousedown', (e) => {
                if (!gameStarted || gameOver) return;
                if (!isPointerLocked) {
                    renderer.domElement.requestPointerLock();
                } else if (e.button === 0) {
                    // å·¦éµå°„æ“Š
                    keys['Mouse0'] = true;
                    shoot();
                } else if (e.button === 2) {
                    // å³éµæ›å½ˆ
                    reload();
                }
            });

            renderer.domElement.addEventListener('mouseup', (e) => {
                if (e.button === 0) keys['Mouse0'] = false;
            });

            // ç¦ç”¨å³éµé¸å–®
            renderer.domElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('restartBtn').addEventListener('click', restartGame);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function drawWeapon() {
            const canvas = document.getElementById('weapon');
            const ctx = canvas.getContext('2d');
            canvas.width = 350;
            canvas.height = 250;

            // æ­¦å™¨å¾Œåº§åŠ›å‹•ç•«
            const recoilOffset = weaponRecoil * 20;

            ctx.clearRect(0, 0, 350, 250);
            ctx.save();
            ctx.translate(0, recoilOffset);

            // æ‰‹è‡‚
            ctx.fillStyle = '#c4a080';
            ctx.beginPath();
            ctx.moveTo(280, 250);
            ctx.lineTo(320, 180);
            ctx.lineTo(350, 180);
            ctx.lineTo(350, 250);
            ctx.fill();

            if (player.currentWeapon === 1) {
                // SMG è¡é‹’æ§
                // æ§èº«ä¸»é«”
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(80, 130, 200, 40);

                // æ§ç®¡
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(20, 140, 80, 20);

                // æ¡æŠŠ
                ctx.fillStyle = '#3a2a1a';
                ctx.fillRect(220, 160, 30, 60);

                // ç„æº–å™¨
                ctx.fillStyle = '#444';
                ctx.fillRect(150, 120, 30, 15);

                // å½ˆåŒ£
                ctx.fillStyle = '#333';
                ctx.fillRect(160, 170, 40, 35);

                // é‡‘å±¬å…‰æ¾¤
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(80, 130, 200, 5);

                // èºçµ²
                ctx.fillStyle = '#555';
                ctx.beginPath();
                ctx.arc(100, 150, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(250, 150, 4, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // ç«ç®­ç ² RPG
                // ç™¼å°„ç®¡
                ctx.fillStyle = '#3a5a3a';
                ctx.fillRect(30, 115, 220, 50);

                // ç™¼å°„ç®¡å‰ç«¯ (å–‡å­å£)
                ctx.fillStyle = '#2a4a2a';
                ctx.beginPath();
                ctx.moveTo(30, 105);
                ctx.lineTo(0, 90);
                ctx.lineTo(0, 190);
                ctx.lineTo(30, 175);
                ctx.closePath();
                ctx.fill();

                // ç™¼å°„ç®¡ç´‹è·¯
                ctx.strokeStyle = '#1a3a1a';
                ctx.lineWidth = 2;
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    ctx.moveTo(50 + i * 40, 115);
                    ctx.lineTo(50 + i * 40, 165);
                    ctx.stroke();
                }

                // ç„æº–å™¨
                ctx.fillStyle = '#444';
                ctx.fillRect(120, 100, 40, 15);
                ctx.fillStyle = '#f00';
                ctx.fillRect(138, 103, 4, 9);

                // æ¡æŠŠ
                ctx.fillStyle = '#3a2a1a';
                ctx.fillRect(200, 160, 35, 60);

                // æ‰³æ©Ÿè­·å¼“
                ctx.strokeStyle = '#2a2a2a';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(210, 175, 15, 0, Math.PI);
                ctx.stroke();

                // è‚©æ‰˜
                ctx.fillStyle = '#4a3a2a';
                ctx.beginPath();
                ctx.moveTo(250, 120);
                ctx.lineTo(320, 130);
                ctx.lineTo(320, 160);
                ctx.lineTo(250, 160);
                ctx.closePath();
                ctx.fill();

                // ç«ç®­å½ˆé ­ (å¦‚æœæœ‰å½ˆè—¥)
                if (player.rocketAmmo > 0) {
                    ctx.fillStyle = '#666';
                    ctx.fillRect(10, 125, 25, 30);
                    ctx.fillStyle = '#c00';
                    ctx.beginPath();
                    ctx.moveTo(10, 125);
                    ctx.lineTo(-5, 140);
                    ctx.lineTo(10, 155);
                    ctx.closePath();
                    ctx.fill();
                }

                // é‡‘å±¬å…‰æ¾¤
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(30, 115, 220, 8);
            }

            ctx.restore();
        }

        function drawMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            canvas.width = 150;
            canvas.height = 150;

            // èƒŒæ™¯
            ctx.fillStyle = 'rgba(0, 20, 0, 0.8)';
            ctx.fillRect(0, 0, 150, 150);

            // ç¶²æ ¼
            ctx.strokeStyle = 'rgba(0, 100, 0, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 150; i += 15) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, 150);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(150, i);
                ctx.stroke();
            }

            const scale = 1.5;
            const centerX = 75;
            const centerY = 75;

            // ç‰†å£
            ctx.fillStyle = '#444';
            walls.forEach(w => {
                const wx = centerX + (w.mesh.position.x - camera.position.x) * scale;
                const wy = centerY + (w.mesh.position.z - camera.position.z) * scale;
                const size = Math.max(3, w.mesh.geometry.parameters.width * scale * 0.3);
                if (wx > -10 && wx < 160 && wy > -10 && wy < 160) {
                    ctx.fillRect(wx - size/2, wy - size/2, size, size);
                }
            });

            // æ¨™é¶ (å½©è‰²é»)
            targets.forEach(t => {
                const tx = centerX + (t.position.x - camera.position.x) * scale;
                const ty = centerY + (t.position.z - camera.position.z) * scale;
                if (tx > 0 && tx < 150 && ty > 0 && ty < 150) {
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.arc(tx, ty, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#f00';
                    ctx.beginPath();
                    ctx.arc(tx, ty, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // ç©å®¶ (ç¶ è‰²ä¸‰è§’å½¢ï¼ŒæŒ‡å‘è¦–è§’æ–¹å‘)
            ctx.fillStyle = '#0f0';
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(-camera.rotation.y);
            ctx.beginPath();
            ctx.moveTo(0, -8);
            ctx.lineTo(-5, 6);
            ctx.lineTo(5, 6);
            ctx.closePath();
            ctx.fill();
            ctx.restore();

            // é‚Šæ¡†
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, 150, 150);
        }

        function showKillStreak() {
            const streakNames = {
                2: 'DOUBLE KILL!',
                3: 'TRIPLE KILL!',
                4: 'MEGA KILL!',
                5: 'ULTRA KILL!',
                6: 'MONSTER KILL!',
                7: 'GODLIKE!'
            };

            if (killStreak >= 2) {
                const name = streakNames[Math.min(killStreak, 7)];
                const streak = document.getElementById('killStreak');
                streak.textContent = name;
                streak.style.opacity = '1';
                streak.style.transform = 'translateX(-50%) scale(1.2)';
                setTimeout(() => {
                    streak.style.opacity = '0';
                    streak.style.transform = 'translateX(-50%) scale(1)';
                }, 1500);
            }
        }

        function createFloatingText(text, x, y) {
            const div = document.createElement('div');
            div.className = 'combo-text';
            div.textContent = text;
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 1000);
        }

        function shoot() {
            // æ ¹æ“šæ­¦å™¨é¡å‹è™•ç†
            if (player.currentWeapon === 1) {
                // SMG è¡é‹’æ§
                if (player.isReloading || player.ammo <= 0) {
                    if (player.ammo <= 0) reload();
                    return;
                }

                const now = Date.now();
                if (now - lastShootTime < 120) return;
                lastShootTime = now;

                player.ammo--;
                updateHUD();
                playSound('shoot');

                // å¾Œåº§åŠ›
                weaponRecoil = 1;

                // æ§å£ç«ç„°
                const flash = document.getElementById('muzzleFlash');
                flash.style.opacity = '1';
                setTimeout(() => flash.style.opacity = '0', 50);

                // å°„ç·šæª¢æ¸¬
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

                // è¨ˆç®—å­å½ˆè»Œè·¡çµ‚é»
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                const start = camera.position.clone();
                const end = start.clone().add(direction.multiplyScalar(100));

                // æª¢æ¸¬ç‰†å£ç¢°æ’
                const wallMeshes = walls.map(w => w.mesh);
                const wallHits = raycaster.intersectObjects(wallMeshes);

                // æª¢æ¸¬åœ°æ¿ç¢°æ’ï¼ˆåœ°æ¿åœ¨ floors é™£åˆ—ï¼‰
                const floorMeshes = floors.map(f => f.mesh);
                const floorHits = raycaster.intersectObjects(floorMeshes);

                // æª¢æ¸¬æ¨™é¶
                const targetMeshes = targets.flatMap(t => t.children);
                const targetHits = raycaster.intersectObjects(targetMeshes);

                // æ±ºå®šæœ€è¿‘çš„æ“Šä¸­é»
                let closestHit = null;
                let closestDist = Infinity;
                let hitType = null;  // 'wall' or 'target'

                if (wallHits.length > 0 && wallHits[0].distance < closestDist) {
                    closestDist = wallHits[0].distance;
                    closestHit = wallHits[0];
                    hitType = 'wall';
                }
                // åœ°æ¿ä¹Ÿç®— wall é¡å‹ï¼ˆæœƒæœ‰å½ˆå­”ï¼‰
                if (floorHits.length > 0 && floorHits[0].distance < closestDist) {
                    closestDist = floorHits[0].distance;
                    closestHit = floorHits[0];
                    hitType = 'wall';
                }
                if (targetHits.length > 0 && targetHits[0].distance < closestDist) {
                    closestDist = targetHits[0].distance;
                    closestHit = targetHits[0];
                    hitType = 'target';
                }

                if (closestHit) {
                    // å‰µå»ºå­å½ˆè»Œè·¡åˆ°æ“Šä¸­é»
                    createBulletTrail(start, closestHit.point);

                    if (hitType === 'wall') {
                        // ç‰†å£/åœ°æ¿æ“Šä¸­æ•ˆæœ - å°å‹ç«èŠ± + å½ˆå­”
                        createBulletImpact(closestHit.point, closestHit.face.normal);
                        playSound('hit');
                        // SMG å­å½ˆæ‰“åœ°æ¿ä¸æœƒè‡ªå‚·ï¼Œåªæœ‰ç«ç®­ç­’æœƒ
                    } else if (hitType === 'target') {
                        const target = closestHit.object.parent;
                        const hitFace = closestHit.object;

                        if (target.userData && target.userData.isTarget) {
                            target.userData.health -= 35;
                            showHitMarker(false);
                            playSound('hit');

                            // æ“Šä¸­æ•ˆæœ - é–ƒç™½
                            target.children.forEach(c => {
                                if (c.material && c.material.color) {
                                    const origColor = c.material.color.getHex();
                                    c.material.color.setHex(0xffffff);
                                    setTimeout(() => c.material.color.setHex(origColor), 80);
                                }
                            });

                            if (target.userData.health <= 0) {
                                // è¨ˆç®—æ“Šä¸­å“ªä¸€é¢çš„åˆ†æ•¸
                                const score = hitFace.userData && hitFace.userData.score ? hitFace.userData.score : 100;
                                roundScore += score;
                                totalScore += score;
                                createFloatingText(`+${score}`, window.innerWidth / 2, window.innerHeight / 2 - 50);
                                updateHUD();
                                explodeTarget(target);
                            }
                        }
                    }
                    return;
                } else {
                    // æ²’æ“Šä¸­ä»»ä½•æ±è¥¿ï¼Œè»Œè·¡åˆ°é è™•
                    createBulletTrail(start, start.clone().add(new THREE.Vector3().copy(direction).normalize().multiplyScalar(50)));
                }

                // æª¢æ¸¬æ•µäºº (ä¿ç•™èˆŠåŠŸèƒ½)
                const enemyMeshes = enemies.flatMap(e => e.children);
                const intersects = raycaster.intersectObjects(enemyMeshes);

                if (intersects.length > 0) {
                    const hit = intersects[0];
                    const enemy = hit.object.parent;

                    if (enemy.userData && enemy.userData.health !== undefined) {
                        const isHeadshot = hit.point.y > enemy.position.y + 1.7;
                        const damage = isHeadshot ? 100 : 35;

                        enemy.userData.health -= damage;
                        showHitMarker(isHeadshot);
                        playSound('hit');

                        enemy.children.forEach(c => {
                            if (c.material) {
                                const origColor = c.material.color.getHex();
                                c.material.color.setHex(0xff0000);
                                setTimeout(() => c.material.color.setHex(origColor), 100);
                            }
                        });

                        if (enemy.userData.health <= 0) {
                            killEnemy(enemy);
                        }
                    }
                }
            } else {
                // ç«ç®­ç ²
                if (player.isReloading || player.rocketAmmo <= 0) {
                    if (player.rocketAmmo <= 0) {
                        showMessage('NO ROCKETS! PRESS R TO RELOAD');
                    }
                    return;
                }

                const now = Date.now();
                if (now - lastShootTime < 800) return;  // ç«ç®­ç™¼å°„é–“éš”è¼ƒé•·
                lastShootTime = now;

                player.rocketAmmo--;
                updateHUD();

                // ç«ç®­ç™¼å°„éŸ³æ•ˆ
                playSound('shoot');
                playSound('reload');

                // å¤§å¾Œåº§åŠ›
                weaponRecoil = 2;
                screenShake = 5;

                // ç™¼å°„ç«ç®­
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                const start = camera.position.clone().add(direction.clone().multiplyScalar(1));
                createRocket(start, direction);

                showMessage('ROCKET FIRED!');
            }
        }

        function killEnemy(enemy) {
            const idx = enemies.indexOf(enemy);
            if (idx > -1) {
                enemies.splice(idx, 1);

                // æ­»äº¡å‹•ç•« - å€’ä¸‹
                const deathAnim = setInterval(() => {
                    enemy.rotation.x += 0.1;
                    enemy.position.y -= 0.05;
                    if (enemy.rotation.x > Math.PI / 2) {
                        clearInterval(deathAnim);
                        scene.remove(enemy);
                    }
                }, 16);

                player.kills++;

                // é€£æ®ºè¨ˆç®—
                const now = Date.now();
                if (now - lastKillTime < 2000) {
                    killStreak++;
                } else {
                    killStreak = 1;
                }
                lastKillTime = now;

                // é¡¯ç¤ºé€£æ®º
                showKillStreak();
                playSound('kill');

                // æµ®å‹•å¾—åˆ†æ–‡å­—
                const points = 100 * killStreak;
                createFloatingText(`+${points}`, window.innerWidth / 2, window.innerHeight / 2 - 50);

                // è¢å¹•éœ‡å‹•
                screenShake = 5;

                updateHUD();
                updateEnemyCount();

                // é¡¯ç¤ºæ“Šæ®ºè¨Šæ¯
                showMessage('ENEMY KILLED!');

                if (enemies.length === 0) {
                    difficulty += 0.5;
                    killStreak = 0;
                    showMessage('WAVE COMPLETE! NEXT WAVE INCOMING...');
                    setTimeout(() => spawnEnemies(), 3000);
                }
            }
        }

        function showHitMarker(isHeadshot) {
            const marker = document.getElementById('hitMarker');
            marker.textContent = isHeadshot ? 'ğŸ’€' : 'âœ–';
            marker.style.color = isHeadshot ? '#ff0' : '#f00';
            marker.style.opacity = '1';
            setTimeout(() => marker.style.opacity = '0', 150);
        }

        function showMessage(text) {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.style.opacity = '1';
            setTimeout(() => msg.style.opacity = '0', 2000);
        }

        function reload() {
            if (player.currentWeapon === 1) {
                if (player.isReloading || player.ammo === player.maxAmmo) return;
                player.isReloading = true;
                showMessage('RELOADING SMG...');
                playSound('reload');
                setTimeout(() => {
                    player.ammo = player.maxAmmo;
                    player.isReloading = false;
                    updateHUD();
                    playSound('reload');
                }, 1500);
            } else {
                if (player.isReloading || player.rocketAmmo === player.maxRocketAmmo) return;
                player.isReloading = true;
                showMessage('RELOADING ROCKETS...');
                playSound('reload');
                setTimeout(() => {
                    player.rocketAmmo = player.maxRocketAmmo;
                    player.isReloading = false;
                    updateHUD();
                    playSound('reload');
                }, 2500);
            }
        }

        // æ­¦å™¨åˆ‡æ›
        function switchWeapon(weaponNum) {
            if (player.currentWeapon === weaponNum) return;
            player.currentWeapon = weaponNum;
            player.isReloading = false;

            // æ›´æ–° HUD é¡¯ç¤º
            if (weaponNum === 1) {
                document.getElementById('weaponPanel').style.opacity = '1';
                document.getElementById('rocketPanel').style.opacity = '0.5';
                document.getElementById('weaponName').textContent = '[ 1 ] SMG';
                showMessage('SWITCHED TO SMG');
            } else {
                document.getElementById('weaponPanel').style.opacity = '0.5';
                document.getElementById('rocketPanel').style.opacity = '1';
                document.getElementById('weaponName').textContent = '[ 2 ] ROCKET';
                showMessage('SWITCHED TO ROCKET LAUNCHER');
            }
            playSound('reload');
            drawWeapon();
        }

        // å‰µå»ºå­å½ˆè»Œè·¡
        function createBulletTrail(start, end) {
            const direction = new THREE.Vector3().subVectors(end, start);
            const length = direction.length();

            const geometry = new THREE.CylinderGeometry(0.02, 0.02, length, 4);
            const material = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.8 });
            const bullet = new THREE.Mesh(geometry, material);

            // å®šä½å­å½ˆ
            bullet.position.copy(start).add(end).multiplyScalar(0.5);
            bullet.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.normalize());

            bullet.userData = { life: 10 };
            scene.add(bullet);
            bullets.push(bullet);
        }

        // å­å½ˆæ“Šä¸­ç‰†å£çš„æ’æ“Šæ•ˆæœ
        function createBulletImpact(position, normal) {
            // å°ç«èŠ±
            for (let i = 0; i < 5; i++) {
                const sparkGeo = new THREE.SphereGeometry(0.03, 4, 4);
                const sparkMat = new THREE.MeshBasicMaterial({
                    color: Math.random() > 0.5 ? 0xffff00 : 0xff8800
                });
                const spark = new THREE.Mesh(sparkGeo, sparkMat);
                spark.position.copy(position);

                // ç«èŠ±æ²¿æ³•ç·šæ–¹å‘å™´å°„
                const vel = new THREE.Vector3(
                    normal.x * 0.1 + (Math.random() - 0.5) * 0.1,
                    normal.y * 0.1 + Math.random() * 0.05,
                    normal.z * 0.1 + (Math.random() - 0.5) * 0.1
                );
                spark.userData = { velocity: vel, life: 15 };
                scene.add(spark);

                const animateSpark = () => {
                    spark.position.add(spark.userData.velocity);
                    spark.userData.velocity.y -= 0.005;
                    spark.userData.life--;
                    spark.material.opacity = spark.userData.life / 15;
                    spark.material.transparent = true;
                    if (spark.userData.life > 0) {
                        requestAnimationFrame(animateSpark);
                    } else {
                        scene.remove(spark);
                    }
                };
                animateSpark();
            }

            // å½ˆå­”æ¨™è¨˜
            const decalGeo = new THREE.CircleGeometry(0.1, 8);
            const decalMat = new THREE.MeshBasicMaterial({
                color: 0x222222,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const decal = new THREE.Mesh(decalGeo, decalMat);
            decal.position.copy(position).add(normal.clone().multiplyScalar(0.02));

            // æ ¹æ“šæ³•ç·šæ–¹å‘è¨­å®šå½ˆå­”è§’åº¦
            if (Math.abs(normal.y) > 0.9) {
                // åœ°æ¿æˆ–å¤©èŠ±æ¿ - æ°´å¹³æ”¾ç½®
                decal.rotation.x = -Math.PI / 2;
            } else {
                // ç‰†å£ - å°é½Šæ³•ç·š
                decal.lookAt(position.clone().add(normal));
            }

            decal.userData = { life: 300 };  // 5ç§’å¾Œæ·¡å‡º
            scene.add(decal);
            decals.push(decal);
        }

        // å‰µå»ºç«ç®­
        function createRocket(start, direction) {
            const rocket = new THREE.Group();

            // ç«ç®­æœ¬é«”
            const bodyGeo = new THREE.CylinderGeometry(0.08, 0.12, 0.5, 8);
            const bodyMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.rotation.x = Math.PI / 2;
            rocket.add(body);

            // ç«ç®­é ­
            const headGeo = new THREE.ConeGeometry(0.08, 0.15, 8);
            const headMat = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.rotation.x = Math.PI / 2;
            head.position.z = -0.3;
            rocket.add(head);

            // å°¾ç„°
            const flameGeo = new THREE.ConeGeometry(0.06, 0.2, 8);
            const flameMat = new THREE.MeshBasicMaterial({ color: 0xff6600 });
            const flame = new THREE.Mesh(flameGeo, flameMat);
            flame.rotation.x = -Math.PI / 2;
            flame.position.z = 0.35;
            rocket.add(flame);

            rocket.position.copy(start);
            rocket.userData = {
                velocity: direction.clone().multiplyScalar(0.8),
                life: 300
            };

            // è®“ç«ç®­æœå‘é£›è¡Œæ–¹å‘
            rocket.lookAt(start.clone().add(direction));

            scene.add(rocket);
            rockets.push(rocket);
        }

        // æ›´æ–°å­å½ˆå’Œç«ç®­
        function updateProjectiles() {
            // æ›´æ–°å­å½ˆè»Œè·¡
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.userData.life--;
                bullet.material.opacity = bullet.userData.life / 10;
                if (bullet.userData.life <= 0) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            }

            // æ›´æ–°ç«ç®­
            for (let i = rockets.length - 1; i >= 0; i--) {
                const rocket = rockets[i];
                rocket.position.add(rocket.userData.velocity);
                rocket.userData.life--;

                // å°¾ç„°é–ƒçˆ
                const flame = rocket.children[2];
                if (flame) {
                    flame.scale.setScalar(0.8 + Math.random() * 0.4);
                }

                // æª¢æ¸¬ç¢°æ’
                let hit = false;
                let hitPoint = rocket.position.clone();

                // æª¢æ¸¬æ¨™é¶ç¢°æ’
                targets.forEach(target => {
                    if (target.userData.health > 0) {
                        const dist = rocket.position.distanceTo(target.position);
                        if (dist < 2) {
                            hit = true;
                            hitPoint = rocket.position.clone();
                        }
                    }
                });

                // æª¢æ¸¬ç‰†å£ç¢°æ’
                walls.forEach(w => {
                    if (w.box.containsPoint(rocket.position)) {
                        hit = true;
                        hitPoint = rocket.position.clone();
                    }
                });

                // æª¢æ¸¬åœ°æ¿ç¢°æ’ï¼ˆç«ç®­æ‰“åœ°æ¿ä¹Ÿæœƒçˆ†ç‚¸ï¼‰
                floors.forEach(f => {
                    if (rocket.position.y < 0.5) {  // æ¥è¿‘åœ°é¢
                        hit = true;
                        hitPoint = rocket.position.clone();
                        hitPoint.y = 0;  // çˆ†ç‚¸é»åœ¨åœ°é¢
                    }
                });

                // è¶…å‡ºç¯„åœ
                if (rocket.userData.life <= 0 || rocket.position.length() > 60) {
                    hit = true;
                }

                if (hit) {
                    // çˆ†ç‚¸ï¼
                    createExplosion(hitPoint);

                    // ç«ç®­è·³ï¼æª¢æ¸¬ç©å®¶è·é›¢çˆ†ç‚¸é»çš„è·é›¢
                    const playerPos = camera.position.clone();
                    const distToPlayer = hitPoint.distanceTo(playerPos);
                    const rocketJumpRadius = 8;  // ç«ç®­è·³æœ‰æ•ˆç¯„åœ

                    if (distToPlayer < rocketJumpRadius) {
                        // è¨ˆç®—å‚·å®³æ¯”ä¾‹ (è·é›¢è¶Šè¿‘å‚·å®³è¶Šé«˜)
                        const damageRatio = 1 - (distToPlayer / rocketJumpRadius);
                        const selfDamage = Math.floor(20 * damageRatio);  // æœ€å¤§è‡ªå‚·20é»

                        // é€ æˆè‡ªå‚·
                        player.health -= selfDamage;
                        if (selfDamage > 0) {
                            showDamage();
                            updateHUD();
                            createFloatingText(`-${selfDamage}`, window.innerWidth / 2, window.innerHeight / 2 + 30);
                        }

                        // ç«ç®­è·³ï¼å½ˆé£›ç©å®¶
                        // å½ˆé£›åŠ›åº¦èˆ‡å‚·å®³æˆæ­£æ¯”ï¼Œæœ€å¤§ç­‰æ–¼è·³èºé«˜åº¦
                        const jumpBoost = player.jumpForce * damageRatio;
                        if (jumpBoost > 0.05) {  // æœ€å°å½ˆé£›é–¾å€¼
                            player.velocity.y = Math.max(player.velocity.y, jumpBoost);
                            player.onGround = false;
                            showMessage('ROCKET JUMP!');
                        }

                        if (player.health <= 0) endGame();
                    }

                    // ç¯„åœå‚·å®³ - æ¨™é¶
                    targets.forEach(target => {
                        if (target.userData.health > 0) {
                            const dist = hitPoint.distanceTo(target.position);
                            if (dist < 6) {
                                const damage = Math.floor(100 * (1 - dist / 6));
                                target.userData.health -= damage;
                                if (target.userData.health <= 0) {
                                    // ç«ç®­æ“Šæ®ºçµ¦é¡å¤–åˆ†æ•¸
                                    const faceScores = target.userData.faceScores || [100, 100, 100, 100];
                                    const score = Math.max(...faceScores);
                                    roundScore += score;
                                    totalScore += score;
                                    createFloatingText(`+${score} ğŸš€`, window.innerWidth / 2, window.innerHeight / 2 - 80);
                                    explodeTarget(target);
                                }
                            }
                        }
                    });

                    scene.remove(rocket);
                    rockets.splice(i, 1);
                    playSound('kill');
                }
            }
        }

        // çˆ†ç‚¸æ•ˆæœ
        function createExplosion(position) {
            // æ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆ
            playSound('explosion');

            // çˆ†ç‚¸å…‰çƒ
            const explosionGeo = new THREE.SphereGeometry(0.5, 16, 16);
            const explosionMat = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 1 });
            const explosion = new THREE.Mesh(explosionGeo, explosionMat);
            explosion.position.copy(position);
            scene.add(explosion);

            // çˆ†ç‚¸å‹•ç•«
            let scale = 1;
            const animateExplosion = () => {
                scale += 0.5;
                explosion.scale.setScalar(scale);
                explosion.material.opacity -= 0.1;
                if (explosion.material.opacity > 0) {
                    requestAnimationFrame(animateExplosion);
                } else {
                    scene.remove(explosion);
                }
            };
            animateExplosion();

            // è¢å¹•éœ‡å‹•
            screenShake = 10;

            // çˆ†ç‚¸ç¢ç‰‡
            for (let i = 0; i < 12; i++) {
                const sparkGeo = new THREE.SphereGeometry(0.1, 4, 4);
                const sparkMat = new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0xff4400 : 0xffff00 });
                const spark = new THREE.Mesh(sparkGeo, sparkMat);
                spark.position.copy(position);
                spark.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.4,
                        Math.random() * 0.3,
                        (Math.random() - 0.5) * 0.4
                    ),
                    life: 30
                };
                scene.add(spark);

                const animateSpark = () => {
                    spark.position.add(spark.userData.velocity);
                    spark.userData.velocity.y -= 0.015;
                    spark.userData.life--;
                    if (spark.userData.life > 0) {
                        requestAnimationFrame(animateSpark);
                    } else {
                        scene.remove(spark);
                    }
                };
                animateSpark();
            }
        }

        function updatePlayer() {
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

            const move = new THREE.Vector3();
            if (keys['KeyW']) move.add(forward);
            if (keys['KeyS']) move.sub(forward);
            if (keys['KeyD']) move.add(right);
            if (keys['KeyA']) move.sub(right);

            const currentSpeed = player.isSprinting ? player.sprintSpeed : player.speed;

            if (move.length() > 0) {
                move.normalize().multiplyScalar(currentSpeed);
                // èµ°è·¯æ™ƒå‹•
                player.bobPhase += currentSpeed * 0.5;
            }

            // è·³èº
            if (keys['Space'] && player.onGround) {
                player.velocity.y = player.jumpForce;
                player.onGround = false;
            }

            // é‡åŠ›
            player.velocity.y -= 0.015;

            const newX = camera.position.x + move.x;
            const newZ = camera.position.z + move.z;
            const newY = camera.position.y + player.velocity.y;

            // ç¢°æ’æª¢æ¸¬
            let canMoveX = true, canMoveZ = true;
            const playerRadius = 0.4;
            const feetY = newY - player.height;  // è…³çš„ä½ç½®
            const headY = newY + 0.3;  // é ­çš„ä½ç½®

            walls.forEach(w => {
                // æª¢æŸ¥ X æ–¹å‘ç§»å‹•
                const testX = new THREE.Box3(
                    new THREE.Vector3(newX - playerRadius, feetY, camera.position.z - playerRadius),
                    new THREE.Vector3(newX + playerRadius, headY, camera.position.z + playerRadius)
                );
                if (testX.intersectsBox(w.box)) canMoveX = false;

                // æª¢æŸ¥ Z æ–¹å‘ç§»å‹•
                const testZ = new THREE.Box3(
                    new THREE.Vector3(camera.position.x - playerRadius, feetY, newZ - playerRadius),
                    new THREE.Vector3(camera.position.x + playerRadius, headY, newZ + playerRadius)
                );
                if (testZ.intersectsBox(w.box)) canMoveZ = false;
            });

            if (canMoveX) camera.position.x = newX;
            if (canMoveZ) camera.position.z = newZ;

            // Y è»¸ç¢°æ’æª¢æ¸¬ï¼ˆç«™åœ¨ç®±å­ä¸Š or æ’åˆ°å¤©èŠ±æ¿ï¼‰
            let groundY = 0;  // é è¨­åœ°é¢é«˜åº¦
            const playerBox = new THREE.Box3(
                new THREE.Vector3(camera.position.x - playerRadius, feetY, camera.position.z - playerRadius),
                new THREE.Vector3(camera.position.x + playerRadius, headY, camera.position.z + playerRadius)
            );

            // æª¢æ¸¬æ–œå¡é«˜åº¦ - å¹³æ»‘éæ¸¡
            ramps.forEach(ramp => {
                const px = camera.position.x;
                const pz = camera.position.z;
                // æª¢æŸ¥æ˜¯å¦åœ¨æ–œå¡Xç¯„åœå…§
                if (px >= ramp.x - ramp.width/2 && px <= ramp.x + ramp.width/2) {
                    const rampHeight = ramp.getHeight(pz);
                    if (rampHeight >= 0) {
                        // åªæœ‰ç•¶ç©å®¶æ¥è¿‘æˆ–ä½æ–¼æ–œå¡é«˜åº¦æ™‚æ‰ç”Ÿæ•ˆ
                        // é€™æ¨£å¯ä»¥è®“ç©å®¶è·³éæ–œå¡æˆ–å¾ä¸Šæ–¹è½ä¸‹
                        if (feetY <= rampHeight + 0.5) {
                            groundY = Math.max(groundY, rampHeight);
                        }
                    }
                }
            });

            walls.forEach(w => {
                if (playerBox.intersectsBox(w.box)) {
                    // æª¢æŸ¥æ˜¯å¦ç«™åœ¨ç‰©é«”ä¸Šé¢
                    const boxTop = w.box.max.y;
                    const boxBottom = w.box.min.y;

                    // å¦‚æœè…³åœ¨ç®±å­é ‚éƒ¨é™„è¿‘ï¼Œç«™ä¸Šå»
                    if (feetY >= boxTop - 0.5 && feetY <= boxTop + 0.5) {
                        groundY = Math.max(groundY, boxTop);
                    }
                    // å¦‚æœé ­æ’åˆ°ç®±å­åº•éƒ¨ï¼Œåœæ­¢ä¸Šå‡
                    else if (player.velocity.y > 0 && headY > boxBottom && feetY < boxBottom) {
                        player.velocity.y = 0;
                    }
                }
            });

            // åœ°é¢æª¢æ¸¬
            if (newY - player.height <= groundY) {
                camera.position.y = groundY + player.height;
                player.velocity.y = 0;
                player.onGround = true;
            } else {
                camera.position.y = newY;
                // åªæœ‰çœŸçš„åœ¨ç©ºä¸­æ‰è¨­ç‚º false
                if (camera.position.y - player.height > groundY + 0.1) {
                    player.onGround = false;
                }
            }

            // èµ°è·¯è¦–è§’æ™ƒå‹•
            if (player.onGround && move.length() > 0) {
                camera.position.y += Math.sin(player.bobPhase) * 0.05;
            }

            // é‚Šç•Œ (æ“´å¤§åœ°åœ–ï¼šå®¤å…§ -50~50ï¼Œæˆ¶å¤–å»¶ä¼¸åˆ° z=150)
            camera.position.x = Math.max(-48, Math.min(48, camera.position.x));
            camera.position.z = Math.max(-48, Math.min(148, camera.position.z));

            // å‚·å®³å€æª¢æ¸¬
            damageZones.forEach(zone => {
                let inZone = false;
                if (zone.type === 'lava' || zone.radius) {
                    // åœ“å½¢å€åŸŸ (å²©æ¼¿)
                    const dist = Math.sqrt((camera.position.x - zone.x) ** 2 + (camera.position.z - zone.z) ** 2);
                    inZone = dist < (zone.radius || 5) && camera.position.y < 3;
                } else {
                    // çŸ©å½¢å€åŸŸ
                    const halfW = zone.w / 2;
                    const halfD = zone.d / 2;
                    inZone = camera.position.x > zone.x - halfW &&
                             camera.position.x < zone.x + halfW &&
                             camera.position.z > zone.z - halfD &&
                             camera.position.z < zone.z + halfD &&
                             camera.position.y < 3;  // åªåœ¨åœ°é¢é™„è¿‘æ‰å—å‚·
                }

                if (inZone) {
                    player.health -= zone.damage;
                    showDamage();
                    updateHUD();
                    if (player.health <= 0) endGame();
                }
            });

            // å½ˆè·³å€æª¢æ¸¬
            jumpPads.forEach(pad => {
                const dist = Math.sqrt((camera.position.x - pad.x) ** 2 + (camera.position.z - pad.z) ** 2);
                if (dist < pad.radius && camera.position.y < player.height + 1 && player.onGround) {
                    // è§¸ç™¼å½ˆè·³ï¼
                    player.velocity.y = pad.jumpForce;
                    player.onGround = false;
                    playSound('jump');  // å½ˆè·³éŸ³æ•ˆ
                    showMessage('BOOST!');

                    // å½ˆè·³è¦–è¦ºæ•ˆæœ - å…‰æŸ±
                    createJumpEffect(pad.x, pad.z);
                }
            });
        }

        // å½ˆè·³å…‰æŸ±æ•ˆæœ
        function createJumpEffect(x, z) {
            const beamGeo = new THREE.CylinderGeometry(0.5, 1.5, 15, 8, 1, true);
            const beamMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            const beam = new THREE.Mesh(beamGeo, beamMat);
            beam.position.set(x, 7.5, z);
            scene.add(beam);

            // æ·¡å‡ºå‹•ç•«
            let opacity = 0.5;
            const animateBeam = () => {
                opacity -= 0.05;
                beam.material.opacity = opacity;
                beam.scale.x *= 0.95;
                beam.scale.z *= 0.95;
                if (opacity > 0) {
                    requestAnimationFrame(animateBeam);
                } else {
                    scene.remove(beam);
                }
            };
            animateBeam();
        }

        function updateEnemies() {
            enemies.forEach(enemy => {
                if (enemy.userData.health <= 0) return;

                const dir = new THREE.Vector3();
                dir.subVectors(camera.position, enemy.position);
                dir.y = 0;
                const dist = dir.length();
                dir.normalize();

                enemy.lookAt(camera.position.x, enemy.position.y, camera.position.z);

                // æ›´æ–°å‹•ç•«ç›¸ä½
                enemy.userData.animPhase += 0.15;

                // å–å¾—å››è‚¢
                const armL = enemy.getObjectByName('armL');
                const armR = enemy.getObjectByName('armR');
                const legL = enemy.getObjectByName('legL');
                const legR = enemy.getObjectByName('legR');

                if (dist > enemy.userData.attackRange) {
                    // ç§»å‹•ä¸­ - èµ°è·¯å‹•ç•«
                    const walkSpeed = 8;
                    const walkAmount = 0.5;

                    if (armL) armL.rotation.x = Math.sin(enemy.userData.animPhase * walkSpeed) * walkAmount;
                    if (armR) armR.rotation.x = -Math.sin(enemy.userData.animPhase * walkSpeed) * walkAmount;
                    if (legL) legL.rotation.x = -Math.sin(enemy.userData.animPhase * walkSpeed) * walkAmount;
                    if (legR) legR.rotation.x = Math.sin(enemy.userData.animPhase * walkSpeed) * walkAmount;

                    // èº«é«”å¾®å¾®å·¦å³æ“ºå‹•
                    enemy.children[0].rotation.z = Math.sin(enemy.userData.animPhase * walkSpeed * 0.5) * 0.05;

                    const newX = enemy.position.x + dir.x * enemy.userData.speed;
                    const newZ = enemy.position.z + dir.z * enemy.userData.speed;

                    let canMove = true;
                    walls.forEach(w => {
                        const testBox = new THREE.Box3(
                            new THREE.Vector3(newX - 0.6, 0, newZ - 0.6),
                            new THREE.Vector3(newX + 0.6, 2.5, newZ + 0.6)
                        );
                        if (testBox.intersectsBox(w.box)) canMove = false;
                    });

                    // é¿å…æ•µäººé‡ç–Š
                    enemies.forEach(other => {
                        if (other !== enemy) {
                            const eDist = enemy.position.distanceTo(other.position);
                            if (eDist < 1.5) canMove = false;
                        }
                    });

                    if (canMove) {
                        enemy.position.x = newX;
                        enemy.position.z = newZ;
                    }

                    enemy.userData.state = 'walking';
                } else {
                    // æ”»æ“Šç¯„åœå…§ - æ”»æ“Šå‹•ç•«
                    enemy.userData.state = 'attacking';

                    // é›™æ‰‹èˆ‰èµ·æ”»æ“Šå‹•ä½œ
                    const attackPhase = Math.sin(enemy.userData.animPhase * 10);
                    if (armL) armL.rotation.x = -1.2 + attackPhase * 0.5;
                    if (armR) armR.rotation.x = -1.2 + attackPhase * 0.5;
                    if (legL) legL.rotation.x = 0;
                    if (legR) legR.rotation.x = 0;

                    const now = Date.now();
                    if (now - enemy.userData.lastAttack > 800) {
                        enemy.userData.lastAttack = now;

                        // è­·ç”²å¸æ”¶å‚·å®³
                        let damage = enemy.userData.damage;
                        if (player.armor > 0) {
                            const armorAbsorb = Math.min(player.armor, damage * 0.6);
                            player.armor -= armorAbsorb;
                            damage -= armorAbsorb;
                        }
                        player.health -= damage;

                        showDamage();
                        updateHUD();

                        if (player.health <= 0) endGame();
                    }
                }

                // çœ¼ç›é–ƒçˆæ•ˆæœ
                const eyeL = enemy.getObjectByName('eyeL');
                const eyeR = enemy.getObjectByName('eyeR');
                if (eyeL && eyeR) {
                    const blink = Math.sin(enemy.userData.animPhase * 3) > 0.95 ? 0.3 : 1;
                    eyeL.scale.setScalar(blink);
                    eyeR.scale.setScalar(blink);
                }
            });
        }

        function showDamage() {
            const overlay = document.getElementById('damageOverlay');
            overlay.style.background = 'radial-gradient(ellipse at center, transparent 0%, rgba(255,0,0,0.6) 100%)';
            overlay.style.opacity = '1';
            playSound('hurt');
            setTimeout(() => overlay.style.opacity = '0', 200);
        }

        function updateHUD() {
            document.getElementById('health').textContent = Math.max(0, Math.floor(player.health));
            document.getElementById('ammo').textContent = player.ammo;
            document.getElementById('maxAmmo').textContent = player.maxAmmo;
            document.getElementById('rocketAmmo').textContent = player.rocketAmmo;
            document.getElementById('roundScore').textContent = roundScore;
            document.getElementById('totalScore').textContent = totalScore;
        }

        function updateEnemyCount() {
            document.getElementById('enemyCount').textContent = targets.length;
        }

        // æ›´æ–°å½ˆå­”æ·¡å‡º
        function updateDecals() {
            for (let i = decals.length - 1; i >= 0; i--) {
                const decal = decals[i];
                decal.userData.life--;
                if (decal.userData.life < 60) {
                    decal.material.opacity = decal.userData.life / 60;
                }
                if (decal.userData.life <= 0) {
                    scene.remove(decal);
                    decals.splice(i, 1);
                }
            }
        }

        // å½ˆè·³å€è¦–è¦ºæ•ˆæœ
        function updateJumpPadEffects() {
            jumpPads.forEach(pad => {
                if (pad.pad) {
                    pad.pad.userData.glowPhase += 0.1;
                    const glow = 0.5 + Math.sin(pad.pad.userData.glowPhase) * 0.3;
                    pad.pad.material.opacity = glow;
                }
                if (pad.light) {
                    pad.light.intensity = 0.8 + Math.sin(pad.pad.userData.glowPhase) * 0.4;
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            if (gameStarted && !gameOver) {
                updatePlayer();
                updateTargets();  // æ›´æ–°æ¨™é¶å‹•ç•«
                updateProjectiles();  // æ›´æ–°å­å½ˆå’Œç«ç®­
                updateDecals();  // æ›´æ–°å½ˆå­”æ·¡å‡º
                updateJumpPadEffects();  // å½ˆè·³å€è¦–è¦ºæ•ˆæœ

                // æ­¦å™¨å¾Œåº§åŠ›æ¢å¾©
                weaponRecoil *= 0.8;
                drawWeapon();
                drawMinimap();

                // è¢å¹•éœ‡å‹•æ•ˆæœ
                if (screenShake > 0) {
                    camera.rotation.z = (Math.random() - 0.5) * screenShake * 0.01;
                    screenShake *= 0.9;
                    if (screenShake < 0.1) {
                        screenShake = 0;
                        camera.rotation.z = 0;
                    }
                } else {
                    // ç¢ºä¿è¦–è§’æ°¸é ç›´ç«‹ (z rotation = 0)
                    camera.rotation.z = 0;
                }

                // è¡åˆºæ™‚çš„é€Ÿåº¦ç·šæ•ˆæœ
                const speedLines = document.getElementById('speedLines');
                if (player.isSprinting && (keys['KeyW'] || keys['KeyS'] || keys['KeyA'] || keys['KeyD'])) {
                    speedLines.style.opacity = '0.5';
                } else {
                    speedLines.style.opacity = '0';
                }

                // æ›´æ–°è¡€æ¢
                document.getElementById('healthBarFill').style.width = player.health + '%';

                if (isPointerLocked && keys['Mouse0']) shoot();
            }

            renderer.render(scene, camera);
        }

        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            gameStarted = true;
            gameOver = false;
            difficulty = 1;
            renderer.domElement.requestPointerLock();
            spawnTargets();  // ç”Ÿæˆæ¨™é¶è€Œä¸æ˜¯æ•µäºº
        }

        function endGame() {
            gameOver = true;
            document.exitPointerLock();
            document.getElementById('finalKills').textContent = player.kills;
            document.getElementById('gameOverScreen').style.display = 'flex';
        }

        function restartGame() {
            targets.forEach(t => scene.remove(t));
            targets = [];
            bullets.forEach(b => scene.remove(b));
            bullets = [];
            rockets.forEach(r => scene.remove(r));
            rockets = [];

            player.health = 100;
            player.armor = 50;
            player.ammo = 30;
            player.rocketAmmo = 10;
            player.kills = 0;
            player.isReloading = false;
            player.velocity = { x: 0, y: 0, z: 0 };
            player.onGround = true;
            player.currentWeapon = 1;
            difficulty = 1;
            killStreak = 0;
            roundScore = 0;
            totalScore = 0;

            // å‡ºç”Ÿåœ¨å®¤å…§å®‰å…¨ä½ç½® (é¿é–‹æ‰€æœ‰å‚·å®³å€)
            camera.position.set(15, player.height, -15);
            cameraYaw = Math.PI / 4;  // é¢å‘ä¸­å¤®
            cameraPitch = 0;
            camera.rotation.order = 'YXZ';
            camera.rotation.y = cameraYaw;
            camera.rotation.x = cameraPitch;
            camera.rotation.z = 0;

            // é‡æ–°éš¨æ©Ÿç”Ÿæˆå‚·å®³å€
            spawnRandomDamageZones();

            gameOver = false;
            updateHUD();
            switchWeapon(1);  // é‡ç½®ç‚º SMG

            document.getElementById('gameOverScreen').style.display = 'none';
            renderer.domElement.requestPointerLock();
            spawnTargets();  // ç”Ÿæˆæ¨™é¶
        }

        init();
    </script>
</body>
</html>
